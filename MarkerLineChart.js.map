{"version":3,"sources":["src/MarkerLineChart.js"],"names":["CustomPropTypes","getTickType","props","xEnd","yEnd","horizontal","isUndefined","console","warn","MarkerLineChart","onMouseEnterLine","e","d","onMouseMoveLine","onMouseLeaveLine","renderRangeValueLine","i","map","callback","eventName","isFunction","partial","onMouseEnter","onMouseMove","onMouseLeave","x","y","xScale","yScale","xVal","yVal","xEndVal","yEndVal","x1","y1","x2","y2","key","every","isFinite","renderValueValueLine","lineLength","nextProps","nextState","shouldUpdate","tickType","data","spacingTop","spacingRight","spacingBottom","spacingLeft","xDomain","yDomain","P","markDomain","markScale","markAccessor","markDataDomain","first","last","sortBy","domainHead","domainTail","dataDomainHead","dataDomainTail","clamp","spacingTail","spacingHead","xScaleType","yScaleType","rangeAxis","rangeStartAccessor","rangeEndAccessor","rangeDataType","Component","propTypes","array","isRequired","valueOrAccessor","bool","number","string","func","defaultProps"],"mappings":"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","file":"MarkerLineChart.js","sourcesContent":["import React from \"react\";\nimport _ from \"lodash\";\nimport PropTypes from \"prop-types\";\n\nimport { methodIfFuncProp } from \"./util.js\";\nimport * as CustomPropTypes from \"./utils/CustomPropTypes\";\nimport { dataTypeFromScaleType } from \"./utils/Scale\";\nimport {\n  makeAccessor2,\n  domainFromRangeData,\n  domainFromData,\n  getDataDomainByAxis\n} from \"./utils/Data\";\nimport xyPropsEqual from \"./utils/xyPropsEqual\";\n\n/**\n * MarkerLine is similar to a bar chart,\n * except that it just draws a line at the data value, rather than a full bar.\n * If the independent variable is a range, the length of the line will represent that range,\n * otherwise all lines will be the same length.\n * The dependent variable must be a single value, not a range.\n */\n\nfunction getTickType(props) {\n  const { xEnd, yEnd, horizontal } = props;\n  // warn if a range is passed for the dependent variable, which is expected to be a value\n  if (\n    (!horizontal && !_.isUndefined(yEnd)) ||\n    (horizontal && !_.isUndefined(xEnd))\n  )\n    console.warn(\n      \"Warning: MarkerLineChart can only show the independent variable as a range, not the dependent variable.\"\n    );\n\n  if (\n    (!horizontal && !_.isUndefined(xEnd)) ||\n    (horizontal && !_.isUndefined(yEnd))\n  )\n    return \"RangeValue\";\n\n  return \"ValueValue\";\n}\n\nexport default class MarkerLineChart extends React.Component {\n  static propTypes = {\n    // the array of data objects\n    data: PropTypes.array.isRequired,\n    // accessor for X & Y coordinates\n    x: CustomPropTypes.valueOrAccessor,\n    y: CustomPropTypes.valueOrAccessor,\n    xEnd: CustomPropTypes.valueOrAccessor,\n    yEnd: CustomPropTypes.valueOrAccessor,\n\n    horizontal: PropTypes.bool,\n    lineLength: PropTypes.number,\n\n    // x & y scale types\n    xScaleType: PropTypes.string,\n    yScaleType: PropTypes.string,\n    xScale: PropTypes.func,\n    yScale: PropTypes.func,\n\n    onMouseEnterLine: PropTypes.func,\n    onMouseMoveLine: PropTypes.func,\n    onMouseLeaveLine: PropTypes.func\n  };\n  static defaultProps = {\n    horizontal: false,\n    lineLength: 10\n  };\n\n  // todo reimplement padding/spacing\n  /*\n  static getOptions(props) {\n    const {data, getX, getXEnd, getY, getYEnd, scaleType, orientation, lineLength} = props;\n    const tickType = getTickType(props);\n    const isVertical = (orientation === 'vertical');\n    const accessors = {x: makeAccessor(getX), y: makeAccessor(getY)};\n    const endAccessors = {x: makeAccessor(getXEnd), y: makeAccessor(getYEnd)};\n\n    let options = {domain: {}, spacing: {}};\n\n    if(tickType === 'RangeValue') { // set range domain for range type\n      let rangeAxis = isVertical ? 'x' : 'y';\n      options.domain[rangeAxis] =\n        rangeAxisDomain(data, accessors[rangeAxis], endAccessors[rangeAxis], scaleType[rangeAxis]);\n    } else {\n      // the value, and therefore the center of the marker line, may fall exactly on the axis min or max,\n      // therefore marker lines need (0.5*lineLength) spacing so they don't hang over the edge of the chart\n      const halfLine = Math.ceil(0.5 * lineLength);\n      options.spacing = isVertical ? {left: halfLine, right: halfLine} : {top: halfLine, bottom: halfLine};\n    }\n\n    return options;\n  }\n  */\n\n  static getSpacing(props) {\n    const tickType = getTickType(props);\n    //no spacing for rangeValue marker charts since line start and end are set explicitly\n    if (tickType === \"RangeValue\")\n      return {\n        spacingTop: 0,\n        spacingRight: 0,\n        spacingBottom: 0,\n        spacingLeft: 0\n      };\n\n    const {\n      lineLength,\n      horizontal,\n      data,\n      xDomain,\n      yDomain,\n      xScale,\n      yScale,\n      x,\n      y\n    } = props;\n    const P = lineLength / 2; //padding\n    const markDomain = horizontal ? yDomain : xDomain;\n    const markScale = horizontal ? yScale : xScale;\n    const markAccessor = horizontal ? makeAccessor2(y) : makeAccessor2(x);\n    const markDataDomain = domainFromData(data, markAccessor);\n\n    // todo refactor/add better comments to clarify\n    // find the edges of the tick domain, and map them through the scale function\n    const [domainHead, domainTail] = _([\n      _.first(markDomain),\n      _.last(markDomain)\n    ])\n      .map(markScale)\n      .sortBy(); //sort the pixel values return by the domain extents\n    // find the edges of the data domain, and map them through the scale function\n    const [dataDomainHead, dataDomainTail] = _([\n      _.first(markDataDomain),\n      _.last(markDataDomain)\n    ])\n      .map(markScale)\n      .sortBy(); //sort the pixel values return by the domain extents\n    // find the necessary spacing (based on bar width) to push the bars completely inside the tick domain\n    const [spacingTail, spacingHead] = [\n      _.clamp(P - (domainTail - dataDomainTail), 0, P),\n      _.clamp(P - (dataDomainHead - domainHead), 0, P)\n    ];\n\n    if (horizontal) {\n      return {\n        spacingTop: spacingHead,\n        spacingBottom: spacingTail,\n        spacingLeft: 0,\n        spacingRight: 0\n      };\n    } else {\n      return {\n        spacingTop: 0,\n        spacingBottom: 0,\n        spacingLeft: spacingHead,\n        spacingRight: spacingTail\n      };\n    }\n  }\n\n  static getDomain(props) {\n    if (getTickType(props) === \"RangeValue\") {\n      // set range domain for range type\n      const {\n        data,\n        x,\n        xEnd,\n        y,\n        yEnd,\n        xScaleType,\n        yScaleType,\n        horizontal\n      } = props;\n\n      // only have to specify range axis domain, other axis uses default domainFromData\n      // in this chart type, the range axis, if there is one, is always the *independent* variable\n      const rangeAxis = horizontal ? \"y\" : \"x\";\n      const rangeStartAccessor = horizontal\n        ? makeAccessor2(y)\n        : makeAccessor2(x);\n      const rangeEndAccessor = horizontal\n        ? makeAccessor2(yEnd)\n        : makeAccessor2(xEnd);\n      const rangeDataType = dataTypeFromScaleType(\n        horizontal ? yScaleType : xScaleType\n      );\n\n      return {\n        [`${rangeAxis}Domain`]: domainFromRangeData(\n          data,\n          rangeStartAccessor,\n          rangeEndAccessor,\n          rangeDataType\n        )\n      };\n    } else {\n      return {};\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const shouldUpdate = !xyPropsEqual(this.props, nextProps, []);\n    return shouldUpdate;\n  }\n\n  onMouseEnterLine = (e, d) => {\n    this.props.onMouseEnterLine(e, d);\n  };\n  onMouseMoveLine = (e, d) => {\n    this.props.onMouseMoveLine(e, d);\n  };\n  onMouseLeaveLine = (e, d) => {\n    this.props.onMouseLeaveLine(e, d);\n  };\n\n  render() {\n    const tickType = getTickType(this.props);\n    return (\n      <g className=\"marker-line-chart\">\n        {tickType === \"RangeValue\"\n          ? this.props.data.map(this.renderRangeValueLine)\n          : this.props.data.map(this.renderValueValueLine)}\n      </g>\n    );\n  }\n\n  renderRangeValueLine = (d, i) => {\n    const [onMouseEnter, onMouseMove, onMouseLeave] = [\n      \"onMouseEnterLine\",\n      \"onMouseMoveLine\",\n      \"onMouseLeaveLine\"\n    ].map(eventName => {\n      // partially apply this bar's data point as 2nd callback argument\n      const callback = methodIfFuncProp(eventName, this.props, this);\n      return _.isFunction(callback) ? _.partial(callback, _, d) : null;\n    });\n\n    const { x, xEnd, y, yEnd, horizontal, xScale, yScale } = this.props;\n    const xVal = xScale(makeAccessor2(x)(d));\n    const yVal = yScale(makeAccessor2(y)(d));\n    const xEndVal = _.isUndefined(xEnd) ? 0 : xScale(makeAccessor2(xEnd)(d));\n    const yEndVal = _.isUndefined(yEnd) ? 0 : yScale(makeAccessor2(yEnd)(d));\n    const [x1, y1] = [xVal, yVal];\n    const x2 = horizontal ? xVal : xEndVal;\n    const y2 = horizontal ? yEndVal : yVal;\n    const key = `marker-line-${i}`;\n\n    if (!_.every([x1, x2, y1, y2], _.isFinite)) return null;\n    return (\n      <line\n        className=\"marker-line\"\n        {...{ x1, x2, y1, y2, key, onMouseEnter, onMouseMove, onMouseLeave }}\n      />\n    );\n  };\n\n  renderValueValueLine = (d, i) => {\n    const [onMouseEnter, onMouseMove, onMouseLeave] = [\n      \"onMouseEnterLine\",\n      \"onMouseMoveLine\",\n      \"onMouseLeaveLine\"\n    ].map(eventName => {\n      // partially apply this bar's data point as 2nd callback argument\n      const callback = methodIfFuncProp(eventName, this.props, this);\n      return _.isFunction(callback) ? _.partial(callback, _, d) : null;\n    });\n\n    const { x, y, horizontal, lineLength, xScale, yScale } = this.props;\n    const xVal = xScale(makeAccessor2(x)(d));\n    const yVal = yScale(makeAccessor2(y)(d));\n    const x1 = !horizontal ? xVal - lineLength / 2 : xVal;\n    const x2 = !horizontal ? xVal + lineLength / 2 : xVal;\n    const y1 = !horizontal ? yVal : yVal - lineLength / 2;\n    const y2 = !horizontal ? yVal : yVal + lineLength / 2;\n    const key = `marker-line-${i}`;\n\n    if (!_.every([x1, x2, y1, y2], _.isFinite)) return null;\n    return (\n      <line\n        className=\"marker-line\"\n        {...{ x1, x2, y1, y2, key, onMouseEnter, onMouseMove, onMouseLeave }}\n      />\n    );\n  };\n}\n"]}