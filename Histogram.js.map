{"version":3,"sources":["src/Histogram.js"],"names":["Histogram","state","histogramData","nextProps","nextState","shouldUpdate","props","value","data","thresholds","binDomain","nice","bins","computeHistogram","getX0","getX1","getLength","xScaleType","yScaleType","domains","xDomain","first","x0","last","x1","yDomain","maxBy","bin","length","accessor","makeHistogram","console","warn","domain","scale","niceBinDomain","ticks","Component","propTypes","array","isRequired","func","xScale","yScale","oneOfType","number","bool","barClassName","string","barStyle","object","onMouseMoveBar","onMouseEnterBar","onMouseLeaveBar","defaultProps","d"],"mappings":"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","file":"Histogram.js","sourcesContent":["import React from \"react\";\nimport _ from \"lodash\";\nimport { histogram, extent, scaleLinear } from \"d3\";\nimport PropTypes from \"prop-types\";\n\nimport xyPropsEqual from \"./utils/xyPropsEqual\";\nimport AreaBarChart from \"./AreaBarChart\";\n\n// todo make histogram work horizontally *or* vertically\nexport default class Histogram extends React.Component {\n  static propTypes = {\n    /**\n     * The array of data objects for the histogram.\n     * These should be individual \"samples\" or \"facts\", not an array of bins -\n     * this component will count and bin the samples for you. If you have data that is already binned,\n     * use the `<AreaBarChart>` component.\n     */\n    data: PropTypes.array.isRequired,\n    /**\n     * Data value accessor function, called once per datum, which returns the values to bin and plot in the histogram.\n     * If `data` is just an array of numbers, this may be the identity function (`function(d) { return d }`).\n     */\n    value: PropTypes.func,\n    /**\n     * D3 scale for X axis - provided by XYPlot\n     */\n    xScale: PropTypes.func,\n    /**\n     * D3 scale for Y axis - provided by XYPlot\n     */\n    yScale: PropTypes.func,\n    /**\n     * Following [d3's thresholds documentation](https://github.com/d3/d3-array#histogram_thresholds) ...\n     *\n     * If a number `count`  is specified, then the domain will be uniformly divided into approximately `count` bins.\n     *\n     * If an array `[x0, x1 ... xN]` is specified, then any value less than `x0` will be placed in the first bin; any value greater than\n     * or equal to `x0` but less than `x1` will be placed in the second bin; and so on. The generated histogram will have `array.length` + 1 bins.\n     */\n    thresholds: PropTypes.oneOfType([PropTypes.number, PropTypes.array])\n      .isRequired,\n    /**\n     * The domain over which your data will be binned. Defined as an array `[min, max]`.\n     * If not provided, binDomain will be the domain of your data values by default.\n     *\n     * Warning: This prop takes priority if `nice = true`.\n     */\n    binDomain: PropTypes.array,\n    /**\n     * If true, nicely rounds the start and end values of your bins.\n     * Implemented using [d3's ticks nicing logic](https://github.com/d3/d3-array#ticks).\n     */\n    nice: PropTypes.bool,\n    /**\n     * Class attribute to be applied to each bar,\n     * or accessor function which returns a class.\n     */\n    barClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    /**\n     * Inline style object to be applied to each bar,\n     * or accessor function which returns a style object.\n     */\n    barStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n    /**\n     * `mousemove` event handler callback, called when user's mouse moves within a bar.\n     */\n    onMouseMoveBar: PropTypes.func,\n    /**\n     * `mouseenter` event handler callback, called when user's mouse enters a bar.\n     */\n    onMouseEnterBar: PropTypes.func,\n    /**\n     * `mouseleave` event handler callback, called when user's mouse leaves a bar.\n     */\n    onMouseLeaveBar: PropTypes.func\n  };\n\n  static defaultProps = { data: [], thresholds: 30, nice: false };\n\n  state = { histogramData: null };\n\n  static getScaleType() {\n    // TODO make histogram work with ordinal scale\n    return { xScaleType: \"linear\", yScaleType: \"linear\" };\n  }\n\n  static getDomain(props) {\n    const { data, value, thresholds, binDomain, nice } = props;\n\n    const bins = Histogram.computeHistogram(\n      data,\n      thresholds,\n      value,\n      binDomain,\n      nice\n    );\n\n    const domains = {\n      xDomain: [_.first(bins).x0, _.last(bins).x1],\n      yDomain: [0, _.maxBy(bins, bin => bin.length).length]\n    };\n\n    return domains;\n  }\n\n  static computeHistogram(data, thresholds, accessor, binDomain, nice) {\n    let makeHistogram = histogram()\n      .value(accessor)\n      .thresholds(thresholds);\n\n    if (binDomain) {\n      // Throw warning if nice = true and binDomain is defined\n      if (nice) {\n        console.warn(\n          \"Warning: if binDomain is defined and nice = true, histogram prioritizes binDomain and disregards nice.\"\n        );\n      }\n\n      // Use user's passed in binDomain to makeHistogram\n      makeHistogram = makeHistogram.domain(binDomain);\n    } else if (nice) {\n      // Create a linear scale to nice values\n      const scale = scaleLinear()\n        .domain(extent(data))\n        .nice();\n\n      // Nicely round domain given temp bins\n      const niceBinDomain = scale.ticks();\n\n      // Set nicely rounded domain as domain for makeHistogram\n      makeHistogram = makeHistogram.domain([\n        _.first(niceBinDomain),\n        _.last(niceBinDomain)\n      ]);\n    }\n\n    const bins = makeHistogram(data);\n\n    return bins;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const shouldUpdate = !xyPropsEqual(this.props, nextProps, []);\n    return shouldUpdate;\n  }\n\n  render() {\n    const { value, data, thresholds, binDomain, nice } = this.props;\n\n    const bins = Histogram.computeHistogram(\n      data,\n      thresholds,\n      value,\n      binDomain,\n      nice\n    );\n\n    if (!bins) return <g />;\n\n    return (\n      <AreaBarChart\n        {...this.props}\n        data={bins}\n        x={getX0}\n        xEnd={getX1}\n        y={getLength}\n      />\n    );\n  }\n}\n\nfunction getX0(d) {\n  return d.x0;\n}\nfunction getX1(d) {\n  return d.x1;\n}\nfunction getLength(d) {\n  return d.length;\n}\n"]}