{"version":3,"sources":["src/Histogram.js"],"names":["Histogram","React","Component","histogramData","getScaleType","xScaleType","yScaleType","getDomain","props","data","value","thresholds","binDomain","nice","bins","computeHistogram","domains","xDomain","_","first","x0","last","x1","yDomain","maxBy","bin","length","accessor","makeHistogram","console","warn","domain","scale","niceBinDomain","ticks","shouldComponentUpdate","nextProps","shouldUpdate","render","getX0","getX1","getLength","PropTypes","array","isRequired","func","xScale","yScale","oneOfType","number","bool","barClassName","string","barStyle","object","onMouseMoveBar","onMouseEnterBar","onMouseLeaveBar","d"],"mappings":"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","sourcesContent":["import { extent, histogram, scaleLinear } from \"d3\";\nimport _ from \"lodash\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport AreaBarChart from \"./AreaBarChart\";\nimport xyPropsEqual from \"./utils/xyPropsEqual\";\n\n/**\n * `Histogram` is used to represent the distribution of numerical data. Histograms, only relate\n * to one variable, where data is typically \"binned\" and counted.\n */\n\n// todo make histogram work horizontally *or* vertically\n// todo make histogram work with ordinal scale\nexport default class Histogram extends React.Component {\n  static propTypes = {\n    /**\n     * The array of data objects for the histogram.\n     * These should be individual \"samples\" or \"facts\", not an array of bins -\n     * this component will count and bin the samples for you. If you have data that is already binned,\n     * use the `<AreaBarChart>` component.\n     */\n    data: PropTypes.array.isRequired,\n    /**\n     * Data value accessor function, called once per datum, which returns the values to bin and plot in the histogram.\n     * If `data` is just an array of numbers, this may be the identity function (`function(d) { return d }`).\n     */\n    value: PropTypes.func,\n    /**\n     * D3 scale for X axis - provided by XYPlot.\n     */\n    xScale: PropTypes.func,\n    /**\n     * D3 scale for Y axis - provided by XYPlot.\n     */\n    yScale: PropTypes.func,\n    /**\n     * Following [d3's thresholds documentation](https://github.com/d3/d3-array#histogram_thresholds) ...\n     *\n     * If a number `count`  is specified, then the domain will be uniformly divided into approximately `count` bins.\n     *\n     * If an array `[x0, x1 ... xN]` is specified, then any value less than `x0` will be placed in the first bin; any value greater than\n     * or equal to `x0` but less than `x1` will be placed in the second bin; and so on. The generated histogram will have `array.length` + 1 bins.\n     */\n    thresholds: PropTypes.oneOfType([PropTypes.number, PropTypes.array])\n      .isRequired,\n    /**\n     * The domain over which your data will be binned. Defined as an array `[min, max]`.\n     * If not provided, binDomain will be the domain of your data values by default.\n     *\n     * Warning: This prop takes priority if `nice = true`.\n     */\n    binDomain: PropTypes.array,\n    /**\n     * If true, nicely rounds the start and end values of your bins.\n     * Implemented using [d3's ticks nicing logic](https://github.com/d3/d3-array#ticks).\n     */\n    nice: PropTypes.bool,\n    /**\n     * Class attribute to be applied to each bar,\n     * or accessor function which returns a class.\n     */\n    barClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    /**\n     * Inline style object to be applied to each bar,\n     * or accessor function which returns a style object.\n     */\n    barStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n    /**\n     * `mousemove` event handler callback, called when user's mouse moves within a bar.\n     */\n    onMouseMoveBar: PropTypes.func,\n    /**\n     * `mouseenter` event handler callback, called when user's mouse enters a bar.\n     */\n    onMouseEnterBar: PropTypes.func,\n    /**\n     * `mouseleave` event handler callback, called when user's mouse leaves a bar.\n     */\n    onMouseLeaveBar: PropTypes.func\n  };\n\n  static defaultProps = { data: [], thresholds: 30, nice: false };\n\n  state = { histogramData: null };\n\n  static getScaleType() {\n    return { xScaleType: \"linear\", yScaleType: \"linear\" };\n  }\n\n  static getDomain(props) {\n    const { data, value, thresholds, binDomain, nice } = props;\n\n    const bins = Histogram.computeHistogram(\n      data,\n      thresholds,\n      value,\n      binDomain,\n      nice\n    );\n\n    const domains = {\n      xDomain: [_.first(bins).x0, _.last(bins).x1],\n      yDomain: [0, _.maxBy(bins, bin => bin.length).length]\n    };\n\n    return domains;\n  }\n\n  static computeHistogram(data, thresholds, accessor, binDomain, nice) {\n    let makeHistogram = histogram()\n      .value(accessor)\n      .thresholds(thresholds);\n\n    if (binDomain) {\n      // Throw warning if nice = true and binDomain is defined\n      if (nice) {\n        console.warn(\n          \"Warning: if binDomain is defined and nice = true, histogram prioritizes binDomain and disregards nice.\"\n        );\n      }\n\n      // Use user's passed in binDomain to makeHistogram\n      makeHistogram = makeHistogram.domain(binDomain);\n    } else if (nice) {\n      // Create a linear scale to nice values\n      const scale = scaleLinear()\n        .domain(extent(data))\n        .nice();\n\n      // Nicely round domain given temp bins\n      const niceBinDomain = scale.ticks();\n\n      // Set nicely rounded domain as domain for makeHistogram\n      makeHistogram = makeHistogram.domain([\n        _.first(niceBinDomain),\n        _.last(niceBinDomain)\n      ]);\n    }\n\n    const bins = makeHistogram(data);\n\n    return bins;\n  }\n\n  shouldComponentUpdate(nextProps) {\n    const shouldUpdate = !xyPropsEqual(this.props, nextProps, []);\n    return shouldUpdate;\n  }\n\n  render() {\n    const { value, data, thresholds, binDomain, nice } = this.props;\n\n    const bins = Histogram.computeHistogram(\n      data,\n      thresholds,\n      value,\n      binDomain,\n      nice\n    );\n\n    if (!bins) return <g />;\n\n    return (\n      <AreaBarChart\n        {...this.props}\n        data={bins}\n        x={getX0}\n        xEnd={getX1}\n        y={getLength}\n      />\n    );\n  }\n}\n\nfunction getX0(d) {\n  return d.x0;\n}\nfunction getX1(d) {\n  return d.x1;\n}\nfunction getLength(d) {\n  return d.length;\n}\n"],"file":"Histogram.js"}