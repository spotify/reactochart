{"version":3,"sources":["src/XAxisLabels.js"],"names":["resolveXLabelsForValues","scale","values","formats","style","force","labels","attempts","goodFormat","_","find","format","testLabels","map","value","i","MeasuredValueLabel","getLabel","defaults","labelStyle","defaultStyle","areLabelsDistinct","push","labelXRanges","label","textAnchor","collisionCount","isUndefined","distinctAttempts","filter","attempt","length","last","minBy","XAxisLabels","React","Component","shouldComponentUpdate","nextProps","nextState","props","getTickDomain","xScale","defaultProps","xTickDomain","getMargin","position","placement","distance","getLabels","zeroMargin","marginTop","marginBottom","marginLeft","marginRight","marginY","max","Math","ceil","height","capitalize","getDefaultFormats","scaleType","timeFormatStrs","numberFormatStrs","identity","tickCount","ticks","propsFormats","formatStrs","isArray","render","labelClassName","spacingTop","spacingBottom","offset","className","transform","x","y","onMouseEnter","onMouseMove","onMouseLeave","onClick","eventName","callback","get","isFunction","partial","dy","text","PropTypes","number","oneOf","func","array","oneOfType","object","string","nice","bool","onMouseEnterLabel","onMouseMoveLabel","onMouseLeaveLabel","onMouseClickLabel","undefined","fontFamily","fontSize","lineHeight","XAxisLabelDebugRect","width","fill"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport MeasuredValueLabel from \"./MeasuredValueLabel\";\nimport {\n  checkLabelsDistinct,\n  countRangeOverlaps,\n  getLabelsXOverhang,\n  getLabelXRange,\n  makeLabelFormatters\n} from \"./utils/Label\";\nimport { getValue } from \"./utils/Data\";\nimport { getScaleTicks, getTickDomain, inferScaleType } from \"./utils/Scale\";\nimport xyPropsEqual from \"./utils/xyPropsEqual\";\n\nfunction resolveXLabelsForValues(scale, values, formats, style, force = true) {\n  // given a set of values to label, and a list of formatters to try,\n  // find the first formatter that produces a set of labels\n  // which are A) distinct and B) fit on the axis without colliding with each other\n  // returns the formatter and the generated labels\n\n  let labels;\n  let attempts = [];\n\n  const goodFormat = _.find(formats, format => {\n    const testLabels = values.map((value, i) => {\n      return MeasuredValueLabel.getLabel({\n        value,\n        format,\n        style: _.defaults(\n          getValue(style.labelStyle, { value }, i),\n          style.defaultStyle\n        )\n      });\n    });\n\n    const areLabelsDistinct = checkLabelsDistinct(testLabels);\n    if (!areLabelsDistinct) {\n      // console.log('labels are not distinct', _.map(testLabels, 'text'));\n      attempts.push({ labels: testLabels, format, areLabelsDistinct });\n      return false;\n    }\n\n    const labelXRanges = testLabels.map(label =>\n      getLabelXRange(scale, label, style.textAnchor || \"middle\")\n    );\n    const collisionCount = countRangeOverlaps(labelXRanges);\n    if (collisionCount) {\n      // console.log(`labels do not fit on X axis, ${collisionCount} collisions`, _.map(testLabels, 'text'));\n      attempts.push({\n        labels: testLabels,\n        format,\n        areLabelsDistinct,\n        collisionCount\n      });\n      return false;\n    }\n\n    labels = testLabels;\n    return true;\n  });\n\n  if (!_.isUndefined(goodFormat)) {\n    // found labels which work, return them\n    return {\n      labels,\n      format: goodFormat,\n      areLabelsDistinct: true,\n      collisionCount: 0\n    };\n  } else {\n    // none of the sets of labels are good\n    if (!force)\n      // if we're not forced to decide, return all the labels we tried (let someone else decide)\n      return { attempts };\n\n    // forced to decide, choose the least bad option\n    // todo warn that we couldn't find good labels\n    const distinctAttempts = attempts.filter(\n      attempt => attempt.areLabelsDistinct\n    );\n    return distinctAttempts.length === 0\n      ? // super bad, we don't have any label sets with distinct labels. return the last attempt.\n        _.last(attempts)\n      : // return the attempt with the fewest collisions between distinct labels\n        _.minBy(distinctAttempts, \"collisionCount\");\n  }\n}\n\nclass XAxisLabels extends React.Component {\n  static propTypes = {\n    height: PropTypes.number,\n    /***\n     * Position of x axis labels. Accepted options are \"top\" or \"bottom\".\n     */\n    position: PropTypes.oneOf([\"top\", \"bottom\"]),\n    /**\n     * Placement of labels in regards to the x axis. Accepted options are \"above\" or \"below\".\n     */\n    placement: PropTypes.oneOf([\"below\", \"above\"]),\n    /**\n     * D3 scale for X axis - provided by XYPlot.\n     */\n    xScale: PropTypes.func,\n    /**\n     * Spacing - provided by XYPlot and used to determine the placement of the label given spacingTop.\n     */\n    spacingTop: PropTypes.number,\n    /**\n     * Spacing - provided by XYPlot and used to determine the placement of the label given spacingBottom.\n     */\n    spacingBottom: PropTypes.number,\n    /**\n     * Label distance from X Axis.\n     */\n    distance: PropTypes.number,\n    /**\n     * Number of ticks on axis.\n     */\n    tickCount: PropTypes.number,\n    /**\n     * Custom ticks to display.\n     */\n    ticks: PropTypes.array,\n    /**\n     * Inline style object applied to each label,\n     * or accessor function which returns a style object\n     *\n     * Disclaimer: labelStyle will merge its defaults with the given labelStyle prop\n     * in order to ensure that our collision library measureText is able to calculate the\n     * smallest amount of possible collissions along the axis. It's therefore dependent on\n     * fontFamily, size and fontStyle to always be passed in. If you're looking to have a centralized\n     * stylesheet, we suggest creating a styled label component that wraps XAxisLabels with your preferred styles.\n     */\n    labelStyle: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n    labelClassName: PropTypes.string,\n    /**\n     * Format to use for the labels or accessor that returns the updated label.\n     *\n     * For example, given labels with real numbers one can pass in 0.[0] to round to the first significant digit.\n     */\n    format: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    /**\n     * Formats to use for the labels in priority order. XAxisLabels will try to be smart about which format\n     * to use that keeps the labels distinct and provides the least amount of collisions when rendered.\n     *\n     * For example, given labels with real numbers one can pass in 0.[0] to round to the first significant digit.\n     */\n    formats: PropTypes.array,\n    /**\n     * Custom labels provided. Note that each object in the array has to be of shape.\n     * `{\n     *  value,\n     *  text,\n     *  height,\n     *  width\n     * }`\n     * value - value you'd like this label to be aligned with\n     * text - text you'd like displayed\n     * height - height of the given label\n     * width - width of the given label\n     */\n    labels: PropTypes.array,\n    /**\n     * Round ticks to capture extent of given x domain from XYPlot.\n     */\n    nice: PropTypes.bool,\n    /**\n     * `mouseenter` event handler callback, called when user's mouse enters the label.\n     */\n    onMouseEnterLabel: PropTypes.func,\n    /**\n     * `mousemove` event handler callback, called when user's mouse moves within the label.\n     */\n    onMouseMoveLabel: PropTypes.func,\n    /**\n     * `mouseleave` event handler callback, called when user's mouse leaves the label.\n     */\n    onMouseLeaveLabel: PropTypes.func,\n    /**\n     * `mouseclick` event handler callback, called when user's mouse clicks the label.\n     */\n    onMouseClickLabel: PropTypes.func,\n    /**\n     * Adds horizontal offset (along the XAxis) to the labels\n     */\n    offset: PropTypes.number\n  };\n\n  static defaultProps = {\n    offset: 0,\n    height: 250,\n    position: \"bottom\",\n    placement: undefined,\n    distance: 4,\n    nice: true,\n    tickCount: 10,\n    ticks: null,\n    labelClassName: \"\",\n    labelStyle: {\n      fontFamily: \"Helvetica, sans-serif\",\n      fontSize: \"14px\",\n      lineHeight: 1,\n      textAnchor: \"middle\"\n    },\n    format: undefined,\n    formats: undefined,\n    labels: undefined\n  };\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return !xyPropsEqual(this.props, nextProps);\n  }\n\n  static getTickDomain(props) {\n    if (!props.xScale) return;\n    props = _.defaults({}, props, XAxisLabels.defaultProps);\n    return { xTickDomain: getTickDomain(props.xScale, props) };\n  }\n\n  static getMargin(props) {\n    props = _.defaults({}, props, XAxisLabels.defaultProps);\n    const { xScale, position, placement, distance } = props;\n    const labels = props.labels || XAxisLabels.getLabels(props);\n    const zeroMargin = {\n      marginTop: 0,\n      marginBottom: 0,\n      marginLeft: 0,\n      marginRight: 0\n    };\n\n    if (\n      (position === \"bottom\" && placement === \"above\") ||\n      (position === \"top\" && placement === \"below\")\n    )\n      return zeroMargin;\n\n    const marginY = _.max(\n      labels.map(label => Math.ceil(distance + label.height))\n    );\n    const [marginLeft, marginRight] = getLabelsXOverhang(\n      xScale,\n      labels,\n      \"middle\"\n    );\n\n    return _.defaults(\n      { [`margin${_.capitalize(position)}`]: marginY, marginLeft, marginRight },\n      zeroMargin\n    );\n  }\n\n  static getDefaultFormats(scaleType) {\n    const timeFormatStrs = [\"YYYY\", \"'YY\", \"MMM YYYY\", \"M/YY\"];\n    const numberFormatStrs = [\n      \"0.[00]a\",\n      \"0,0\",\n      \"0.[0]\",\n      \"0.[00]\",\n      \"0.[0000]\",\n      \"0.[000000]\"\n    ];\n\n    return scaleType === \"ordinal\"\n      ? [_.identity]\n      : scaleType === \"time\"\n        ? timeFormatStrs\n        : numberFormatStrs;\n  }\n\n  static getLabels(props) {\n    const { tickCount, labelStyle, xScale } = _.defaults(\n      props,\n      {},\n      XAxisLabels.defaultProps\n    );\n    const ticks = props.ticks || getScaleTicks(xScale, null, tickCount);\n    const style = {\n      labelStyle,\n      defaultStyle: XAxisLabels.defaultProps.labelStyle\n    };\n\n    const scaleType = inferScaleType(xScale);\n    const propsFormats = props.format ? [props.format] : props.formats;\n    const formatStrs =\n      _.isArray(propsFormats) && propsFormats.length\n        ? propsFormats\n        : XAxisLabels.getDefaultFormats(scaleType);\n    const formats = makeLabelFormatters(formatStrs, scaleType);\n\n    // todo resolve ticks also\n    // if there are so many ticks that no combination of labels can fit on the axis,\n    // nudge down the tickCount and try again\n    // doing this will require communicating the updated ticks/tickCount back to the parent element...\n\n    const { labels } = resolveXLabelsForValues(xScale, ticks, formats, style);\n\n    return labels;\n  }\n\n  render() {\n    const {\n      height,\n      xScale,\n      position,\n      distance,\n      labelStyle,\n      labelClassName,\n      spacingTop,\n      spacingBottom,\n      offset\n    } = this.props;\n    const labels = this.props.labels || XAxisLabels.getLabels(this.props);\n    const placement =\n      this.props.placement || (position === \"top\" ? \"above\" : \"below\");\n    const className = `rct-chart-value-label rct-chart-value-label-x ${labelClassName}`;\n    const transform =\n      position === \"bottom\"\n        ? `translate(0, ${height + spacingBottom})`\n        : `translate(0, ${-spacingTop})`;\n    // todo: position: 'zero' to position along the zero line\n    // example include having both positive and negative areas and youd like labels just on zero line\n\n    return (\n      <g className=\"rct-chart-value-labels-x\" transform={transform}>\n        {labels.map((label, i) => {\n          const x = xScale(label.value) + offset;\n          const y = placement === \"above\" ? -label.height - distance : distance;\n          const [onMouseEnter, onMouseMove, onMouseLeave, onClick] = [\n            \"onMouseEnterLabel\",\n            \"onMouseMoveLabel\",\n            \"onMouseLeaveLabel\",\n            \"onMouseClickLabel\"\n          ].map(eventName => {\n            // partially apply this label's data point as 2nd callback argument\n            const callback = _.get(this.props, eventName);\n            return _.isFunction(callback)\n              ? _.partial(callback, _, label.value)\n              : null;\n          });\n\n          const style = _.defaults(\n            { textAnchor: \"middle\" },\n            getValue(labelStyle, { x, y, ...label }, i),\n            XAxisLabels.defaultProps.labelStyle\n          );\n\n          return (\n            <g\n              key={`x-axis-label-${i}`}\n              {...{ onMouseEnter, onMouseMove, onMouseLeave, onClick }}\n            >\n              {/* <XAxisLabelDebugRect {...{x, y, label}}/> */}\n              <MeasuredValueLabel\n                value={label.value}\n                {...{\n                  x,\n                  y,\n                  className,\n                  dy: \"0.8em\",\n                  style\n                }}\n              >\n                {label.text}\n              </MeasuredValueLabel>\n            </g>\n          );\n        })}\n      </g>\n    );\n  }\n}\n\nclass XAxisLabelDebugRect extends React.Component {\n  render() {\n    const { x, y, label } = this.props;\n    return (\n      <rect\n        {...{\n          x: x - label.width / 2,\n          y: y,\n          width: label.width,\n          height: label.height,\n          fill: \"orange\"\n        }}\n      />\n    );\n  }\n}\n\nexport default XAxisLabels;\n"],"file":"XAxisLabels.js"}