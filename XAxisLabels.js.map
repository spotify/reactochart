{"version":3,"sources":["src/XAxisLabels.js"],"names":["resolveXLabelsForValues","scale","values","formats","style","force","labels","attempts","goodFormat","find","testLabels","map","getLabel","value","format","areLabelsDistinct","push","labelXRanges","label","textAnchor","collisionCount","isUndefined","distinctAttempts","filter","attempt","length","last","minBy","XAxisLabels","nextProps","nextState","props","height","xScale","position","distance","labelStyle","labelClassName","onMouseEnterLabel","onMouseMoveLabel","onMouseLeaveLabel","spacingTop","spacingBottom","getLabels","placement","className","transform","i","x","y","callback","get","eventName","isFunction","partial","onMouseEnter","onMouseMove","onMouseLeave","dy","text","defaults","defaultProps","xTickDomain","zeroMargin","marginTop","marginBottom","marginLeft","marginRight","marginY","max","Math","ceil","capitalize","scaleType","timeFormatStrs","numberFormatStrs","identity","tickCount","ticks","propsFormats","formatStrs","isArray","getDefaultFormats","Component","propTypes","func","undefined","nice","fontFamily","fontSize","lineHeight","XAxisLabelDebugRect","width","fill"],"mappings":"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","file":"XAxisLabels.js","sourcesContent":["import React from \"react\";\nimport _ from \"lodash\";\nimport PropTypes from \"prop-types\";\n\nimport MeasuredValueLabel from \"./MeasuredValueLabel\";\nimport { getScaleTicks, inferScaleType, getTickDomain } from \"./utils/Scale\";\nimport {\n  checkLabelsDistinct,\n  countRangeOverlaps,\n  makeLabelFormatters,\n  getLabelXRange,\n  getLabelsXOverhang\n} from \"./utils/Label\";\nimport xyPropsEqual from \"./utils/xyPropsEqual\";\n\nfunction resolveXLabelsForValues(scale, values, formats, style, force = true) {\n  // given a set of values to label, and a list of formatters to try,\n  // find the first formatter that produces a set of labels\n  // which are A) distinct and B) fit on the axis without colliding with each other\n  // returns the formatter and the generated labels\n\n  let labels;\n  let attempts = [];\n  const goodFormat = _.find(formats, format => {\n    const testLabels = values.map(value =>\n      MeasuredValueLabel.getLabel({ value, format, style })\n    );\n\n    const areLabelsDistinct = checkLabelsDistinct(testLabels);\n    if (!areLabelsDistinct) {\n      // console.log('labels are not distinct', _.map(testLabels, 'text'));\n      attempts.push({ labels: testLabels, format, areLabelsDistinct });\n      return false;\n    }\n\n    const labelXRanges = testLabels.map(label =>\n      getLabelXRange(scale, label, style.textAnchor || \"middle\")\n    );\n    const collisionCount = countRangeOverlaps(labelXRanges);\n    if (collisionCount) {\n      // console.log(`labels do not fit on X axis, ${collisionCount} collisions`, _.map(testLabels, 'text'));\n      attempts.push({\n        labels: testLabels,\n        format,\n        areLabelsDistinct,\n        collisionCount\n      });\n      return false;\n    }\n\n    labels = testLabels;\n    return true;\n  });\n\n  if (!_.isUndefined(goodFormat)) {\n    // found labels which work, return them\n    return {\n      labels,\n      format: goodFormat,\n      areLabelsDistinct: true,\n      collisionCount: 0\n    };\n  } else {\n    // none of the sets of labels are good\n    if (!force)\n      // if we're not forced to decide, return all the labels we tried (let someone else decide)\n      return { attempts };\n\n    // forced to decide, choose the least bad option\n    // todo warn that we couldn't find good labels\n    const distinctAttempts = attempts.filter(\n      attempt => attempt.areLabelsDistinct\n    );\n    return distinctAttempts.length === 0\n      ? // super bad, we don't have any label sets with distinct labels. return the last attempt.\n        _.last(attempts)\n      : // return the attempt with the fewest collisions between distinct labels\n        _.minBy(distinctAttempts, \"collisionCount\");\n  }\n}\n\nclass XAxisLabels extends React.Component {\n  static propTypes = {\n    xScale: PropTypes.func,\n    // Label Handling\n    onMouseEnterLabel: PropTypes.func,\n    onMouseMoveLabel: PropTypes.func,\n    onMouseLeaveLabel: PropTypes.func\n  };\n  static defaultProps = {\n    height: 250,\n    position: \"bottom\",\n    placement: undefined,\n    distance: 4,\n    nice: true,\n    tickCount: 10,\n    ticks: null,\n    labelClassName: \"\",\n    labelStyle: {\n      fontFamily: \"Helvetica, sans-serif\",\n      fontSize: \"14px\",\n      lineHeight: 1,\n      textAnchor: \"middle\"\n    },\n    format: undefined,\n    formats: undefined,\n    labels: undefined,\n    spacingTop: 0,\n    spacingBottom: 0\n  };\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return !xyPropsEqual(this.props, nextProps);\n  }\n\n  static getTickDomain(props) {\n    if (!props.xScale) return;\n    props = _.defaults({}, props, XAxisLabels.defaultProps);\n    return { xTickDomain: getTickDomain(props.xScale, props) };\n  }\n\n  static getMargin(props) {\n    props = _.defaults({}, props, XAxisLabels.defaultProps);\n    const { xScale, position, placement, distance, labelStyle } = props;\n    const labels = props.labels || XAxisLabels.getLabels(props);\n    const zeroMargin = {\n      marginTop: 0,\n      marginBottom: 0,\n      marginLeft: 0,\n      marginRight: 0\n    };\n\n    if (\n      (position === \"bottom\" && placement === \"above\") ||\n      (position === \"top\" && placement === \"below\")\n    )\n      return zeroMargin;\n\n    const marginY = _.max(\n      labels.map(label => Math.ceil(distance + label.height))\n    );\n    const [marginLeft, marginRight] = getLabelsXOverhang(\n      xScale,\n      labels,\n      labelStyle.textAnchor || \"middle\"\n    );\n\n    return _.defaults(\n      { [`margin${_.capitalize(position)}`]: marginY, marginLeft, marginRight },\n      zeroMargin\n    );\n  }\n\n  static getDefaultFormats(scaleType) {\n    const timeFormatStrs = [\"YYYY\", \"'YY\", \"MMM YYYY\", \"M/YY\"];\n    const numberFormatStrs = [\n      \"0.[00]a\",\n      \"0,0\",\n      \"0.[0]\",\n      \"0.[00]\",\n      \"0.[0000]\",\n      \"0.[000000]\"\n    ];\n\n    return scaleType === \"ordinal\"\n      ? [_.identity]\n      : scaleType === \"time\"\n        ? timeFormatStrs\n        : numberFormatStrs;\n  }\n\n  static getLabels(props) {\n    const { tickCount, labelStyle, xScale } = _.defaults(\n      props,\n      {},\n      XAxisLabels.defaultProps\n    );\n    const ticks = props.ticks || getScaleTicks(xScale, null, tickCount);\n    const style = _.defaults(labelStyle, XAxisLabels.defaultProps.labelStyle);\n\n    const scaleType = inferScaleType(xScale);\n    const propsFormats = props.format ? [props.format] : props.formats;\n    const formatStrs =\n      _.isArray(propsFormats) && propsFormats.length\n        ? propsFormats\n        : XAxisLabels.getDefaultFormats(scaleType);\n    const formats = makeLabelFormatters(formatStrs, scaleType);\n\n    // todo resolve ticks also\n    // if there are so many ticks that no combination of labels can fit on the axis,\n    // nudge down the tickCount and try again\n    // doing this will require communicating the updated ticks/tickCount back to the parent element...\n\n    const { labels } = resolveXLabelsForValues(xScale, ticks, formats, style);\n    // console.log('found labels', labels);\n    return labels;\n  }\n\n  render() {\n    const {\n      height,\n      xScale,\n      position,\n      distance,\n      labelStyle,\n      labelClassName,\n      onMouseEnterLabel,\n      onMouseMoveLabel,\n      onMouseLeaveLabel,\n      spacingTop,\n      spacingBottom\n    } = this.props;\n    const labels = this.props.labels || XAxisLabels.getLabels(this.props);\n    const placement =\n      this.props.placement || (position === \"top\" ? \"above\" : \"below\");\n    const className = `chart-value-label chart-value-label-x ${labelClassName}`;\n    const transform =\n      position === \"bottom\"\n        ? `translate(0, ${height + spacingBottom})`\n        : `translate(0, ${-spacingTop})`;\n    // todo: position: 'zero' to position along the zero line\n\n    return (\n      <g className=\"chart-value-labels-x\" transform={transform}>\n        {labels.map((label, i) => {\n          const x = xScale(label.value);\n          const y = placement === \"above\" ? -label.height - distance : distance;\n          const [onMouseEnter, onMouseMove, onMouseLeave] = [\n            \"onMouseEnterLabel\",\n            \"onMouseMoveLabel\",\n            \"onMouseLeaveLabel\"\n          ].map(eventName => {\n            // partially apply this bar's data point as 2nd callback argument\n            const callback = _.get(this.props, eventName);\n            return _.isFunction(callback)\n              ? _.partial(callback, _, label.value)\n              : null;\n          });\n\n          return (\n            <g\n              key={`x-axis-label-${i}`}\n              {...{ onMouseEnter, onMouseMove, onMouseLeave }}\n            >\n              {/* <XAxisLabelDebugRect {...{x, y, label}}/> */}\n              <MeasuredValueLabel\n                value={label.value}\n                {...{ x, y, className, dy: \"0.8em\", style: labelStyle }}\n              >\n                {label.text}\n              </MeasuredValueLabel>\n            </g>\n          );\n        })}\n      </g>\n    );\n  }\n}\n\nclass XAxisLabelDebugRect extends React.Component {\n  render() {\n    const { x, y, label } = this.props;\n    return (\n      <rect\n        {...{\n          x: x - label.width / 2,\n          y: y,\n          width: label.width,\n          height: label.height,\n          fill: \"orange\"\n        }}\n      />\n    );\n  }\n}\n\nexport default XAxisLabels;\n"]}