{"version":3,"sources":["src/YAxisLabels.js"],"names":["resolveYLabelsForValues","scale","values","formats","style","force","labels","attempts","goodFormat","find","testLabels","map","getLabel","value","format","areLabelsDistinct","push","isUndefined","collisionCount","last","YAxisLabels","nextProps","nextState","props","width","yScale","position","distance","labelStyle","labelClassName","onMouseEnterLabel","onMouseMoveLabel","onMouseLeaveLabel","spacingLeft","spacingRight","placement","className","textAnchor","defaults","defaultProps","getLabels","transform","label","i","y","x","callback","get","eventName","isFunction","partial","onMouseEnter","onMouseMove","onMouseLeave","dy","text","yTickDomain","zeroMargin","marginTop","marginBottom","marginLeft","marginRight","marginX","max","Math","ceil","capitalize","scaleType","timeFormatStrs","numberFormatStrs","identity","tickCount","ticks","propsFormats","formatStrs","isArray","length","getDefaultFormats","Component","propTypes","func","height","number","oneOf","nice","bool","array","string","object","fontFamily","fontSize","lineHeight","YAxisLabelDebugRect","xAdj","fill"],"mappings":"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","file":"YAxisLabels.js","sourcesContent":["import React from \"react\";\nimport _ from \"lodash\";\nimport PropTypes from \"prop-types\";\n\nimport MeasuredValueLabel from \"./MeasuredValueLabel\";\nimport { getScaleTicks, inferScaleType, getTickDomain } from \"./utils/Scale\";\nimport {\n  checkLabelsDistinct,\n  countRangeOverlaps,\n  makeLabelFormatters,\n  getLabelXRange,\n  getLabelsYOverhang\n} from \"./utils/Label\";\nimport xyPropsEqual from \"./utils/xyPropsEqual\";\n\nfunction resolveYLabelsForValues(scale, values, formats, style, force = true) {\n  // given a set of Y-values to label, and a list of formatters to try,\n  // find the first formatter that produces a set of labels which are distinct\n  // since we currently do not support rotated axis value labels,\n  // we do not check if they fit on the axis (unlike X labels), since all Y labels will have the same height\n  // returns the formatter and the generated labels\n\n  let labels;\n  let attempts = [];\n  const goodFormat = _.find(formats, format => {\n    const testLabels = values.map(value =>\n      MeasuredValueLabel.getLabel({ value, format, style })\n    );\n\n    const areLabelsDistinct = checkLabelsDistinct(testLabels);\n    if (!areLabelsDistinct) {\n      // console.log('labels are not distinct', _.map(testLabels, 'text'));\n      attempts.push({ labels: testLabels, format, areLabelsDistinct });\n      return false;\n    }\n\n    labels = testLabels;\n    return true;\n  });\n\n  if (!_.isUndefined(goodFormat)) {\n    // found labels which work, return them\n    return {\n      labels,\n      format: goodFormat,\n      areLabelsDistinct: true,\n      collisionCount: 0\n    };\n  } else {\n    // none of the sets of labels are good\n    // if we're not forced to decide, return all the labels we tried (let someone else decide)\n    if (!force) return { attempts };\n\n    // forced to decide, choose the least bad option\n    // super bad, we don't have any label sets with distinct labels. return the last attempt.\n    return _.last(attempts);\n  }\n}\n\nclass YAxisLabels extends React.Component {\n  static propTypes = {\n    yScale: PropTypes.func,\n    height: PropTypes.number,\n    width: PropTypes.number,\n    position: PropTypes.oneOf([\"left\", \"right\"]),\n    placement: PropTypes.oneOf([\"before\", \"after\"]),\n    distance: PropTypes.number,\n    nice: PropTypes.bool,\n    tickCount: PropTypes.number,\n    ticks: PropTypes.array,\n    labelClassName: PropTypes.string,\n    labelStyle: PropTypes.object,\n    spacingLeft: PropTypes.number,\n    spacingRight: PropTypes.number,\n    // Label Handling\n    onMouseEnterLabel: PropTypes.func,\n    onMouseMoveLabel: PropTypes.func,\n    onMouseLeaveLabel: PropTypes.func\n    // format: undefined,\n    // formats: undefined,\n    // labels: undefined\n  };\n  static defaultProps = {\n    height: 250,\n    width: 400,\n    position: \"left\",\n    distance: 4,\n    nice: true,\n    tickCount: 10,\n    ticks: null,\n    labelClassName: \"\",\n    labelStyle: {\n      fontFamily: \"Helvetica, sans-serif\",\n      fontSize: \"14px\",\n      lineHeight: 1,\n      textAnchor: \"end\"\n    },\n    spacingLeft: 0,\n    spacingRight: 0\n  };\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return !xyPropsEqual(this.props, nextProps);\n  }\n\n  static getTickDomain(props) {\n    if (!props.yScale) return;\n    props = _.defaults({}, props, YAxisLabels.defaultProps);\n    return { yTickDomain: getTickDomain(props.yScale, props) };\n  }\n\n  static getMargin(props) {\n    props = _.defaults({}, props, YAxisLabels.defaultProps);\n    const { yScale, position, placement, distance, labelStyle } = props;\n    const labels = props.labels || YAxisLabels.getLabels(props);\n    const zeroMargin = {\n      marginTop: 0,\n      marginBottom: 0,\n      marginLeft: 0,\n      marginRight: 0\n    };\n\n    if (\n      (position === \"left\" && placement === \"after\") ||\n      (position === \"right\" && placement === \"before\")\n    )\n      return zeroMargin;\n\n    const marginX = _.max(\n      labels.map(label => Math.ceil(distance + label.width))\n    );\n    const [marginTop, marginBottom] = getLabelsYOverhang(\n      yScale,\n      labels,\n      \"middle\"\n    );\n\n    return _.defaults(\n      { [`margin${_.capitalize(position)}`]: marginX, marginTop, marginBottom },\n      zeroMargin\n    );\n  }\n\n  static getDefaultFormats(scaleType) {\n    const timeFormatStrs = [\"YYYY\", \"'YY\", \"MMM YYYY\", \"M/YY\"];\n    const numberFormatStrs = [\n      \"0.[00]a\",\n      \"0,0\",\n      \"0.[0]\",\n      \"0.[00]\",\n      \"0.[0000]\",\n      \"0.[000000]\"\n    ];\n\n    return scaleType === \"ordinal\"\n      ? [_.identity]\n      : scaleType === \"time\"\n        ? timeFormatStrs\n        : numberFormatStrs;\n  }\n\n  static getLabels(props) {\n    const { tickCount, labelStyle, yScale } = _.defaults(\n      props,\n      {},\n      YAxisLabels.defaultProps\n    );\n    const ticks = props.ticks || getScaleTicks(yScale, null, tickCount);\n    const style = _.defaults(labelStyle, YAxisLabels.defaultProps.labelStyle);\n\n    const scaleType = inferScaleType(yScale);\n    const propsFormats = props.format ? [props.format] : props.formats;\n    const formatStrs =\n      _.isArray(propsFormats) && propsFormats.length\n        ? propsFormats\n        : YAxisLabels.getDefaultFormats(scaleType);\n    const formats = makeLabelFormatters(formatStrs, scaleType);\n\n    // todo resolve ticks also\n    // if there are so many ticks that no combination of labels can fit on the axis,\n    // nudge down the tickCount and try again\n    // doing this will require communicating the updated ticks/tickCount back to the parent element...\n\n    const { labels } = resolveYLabelsForValues(yScale, ticks, formats, style);\n    // console.log('resolveYLabelsForValues took ', performance.now() - start);\n    // console.log('found labels', labels);\n    return labels;\n  }\n\n  render() {\n    // todo: position: 'zero' prop to position along the zero line\n    const {\n      width,\n      yScale,\n      position,\n      distance,\n      labelStyle,\n      labelClassName,\n      onMouseEnterLabel,\n      onMouseMoveLabel,\n      onMouseLeaveLabel,\n      spacingLeft,\n      spacingRight\n    } = this.props;\n    const placement =\n      this.props.placement || (position === \"left\" ? \"before\" : \"after\");\n    const className = `chart-value-label chart-value-label-y ${labelClassName}`;\n    const textAnchor = placement === \"before\" ? \"end\" : \"start\";\n    const style = _.defaults(\n      { textAnchor },\n      labelStyle,\n      YAxisLabels.defaultProps.labelStyle\n    );\n    const labels = this.props.labels || YAxisLabels.getLabels(this.props);\n    const transform =\n      position === \"left\"\n        ? `translate(${-spacingLeft}, 0)`\n        : `translate(${width + spacingRight}, 0)`;\n\n    return (\n      <g className=\"chart-value-labels-y\" transform={transform}>\n        {labels.map((label, i) => {\n          const y = yScale(label.value);\n          const x = placement === \"before\" ? -distance : distance;\n\n          const [onMouseEnter, onMouseMove, onMouseLeave] = [\n            \"onMouseEnterLabel\",\n            \"onMouseMoveLabel\",\n            \"onMouseLeaveLabel\"\n          ].map(eventName => {\n            // partially apply this bar's data point as 2nd callback argument\n            const callback = _.get(this.props, eventName);\n            return _.isFunction(callback)\n              ? _.partial(callback, _, label.value)\n              : null;\n          });\n\n          return (\n            <g\n              key={`x-axis-label-${i}`}\n              {...{ onMouseEnter, onMouseMove, onMouseLeave }}\n            >\n              {/* <YAxisLabelDebugRect {...{x, y, label, style}}/> */}\n              <MeasuredValueLabel\n                value={label.value}\n                {...{ x, y, className, dy: \"0.35em\", style }}\n              >\n                {label.text}\n              </MeasuredValueLabel>\n            </g>\n          );\n        })}\n      </g>\n    );\n  }\n}\n\nclass YAxisLabelDebugRect extends React.Component {\n  render() {\n    const { x, y, label, style } = this.props;\n    const xAdj = style.textAnchor === \"end\" ? x - label.width : x;\n    return (\n      <rect\n        {...{\n          x: xAdj,\n          y: y - label.height / 2,\n          width: label.width,\n          height: label.height,\n          fill: \"orange\"\n        }}\n      />\n    );\n  }\n}\n\nexport default YAxisLabels;\n"]}