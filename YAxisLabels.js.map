{"version":3,"sources":["src/YAxisLabels.js"],"names":["resolveYLabelsForValues","scale","values","formats","style","force","labels","attempts","goodFormat","_","find","format","testLabels","map","value","i","MeasuredValueLabel","getLabel","defaults","labelStyle","defaultStyle","areLabelsDistinct","push","isUndefined","collisionCount","last","YAxisLabels","React","Component","shouldComponentUpdate","nextProps","nextState","props","getTickDomain","yScale","defaultProps","yTickDomain","getMargin","position","placement","distance","getLabels","zeroMargin","marginTop","marginBottom","marginLeft","marginRight","marginX","max","label","Math","ceil","width","capitalize","getDefaultFormats","scaleType","timeFormatStrs","numberFormatStrs","identity","tickCount","ticks","propsFormats","formatStrs","isArray","length","render","labelClassName","spacingLeft","spacingRight","offset","className","textAnchor","transform","y","x","onMouseEnter","onMouseMove","onMouseLeave","onClick","eventName","callback","get","isFunction","partial","dy","text","PropTypes","func","height","number","oneOf","nice","bool","array","oneOfType","object","string","onMouseEnterLabel","onMouseMoveLabel","onMouseLeaveLabel","onMouseClickLabel","fontFamily","fontSize","lineHeight","YAxisLabelDebugRect","xAdj","fill"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport MeasuredValueLabel from \"./MeasuredValueLabel\";\nimport {\n  checkLabelsDistinct,\n  getLabelsYOverhang,\n  makeLabelFormatters\n} from \"./utils/Label\";\nimport { getValue } from \"./utils/Data\";\nimport { getScaleTicks, getTickDomain, inferScaleType } from \"./utils/Scale\";\nimport xyPropsEqual from \"./utils/xyPropsEqual\";\n\nfunction resolveYLabelsForValues(scale, values, formats, style, force = true) {\n  // given a set of Y-values to label, and a list of formatters to try,\n  // find the first formatter that produces a set of labels which are distinct\n  // since we currently do not support rotated axis value labels,\n  // we do not check if they fit on the axis (unlike X labels), since all Y labels will have the same height\n  // returns the formatter and the generated labels\n\n  let labels;\n  let attempts = [];\n  const goodFormat = _.find(formats, format => {\n    const testLabels = values.map((value, i) =>\n      MeasuredValueLabel.getLabel({\n        value,\n        format,\n        style: _.defaults(\n          getValue(style.labelStyle, { value }, i),\n          style.defaultStyle\n        )\n      })\n    );\n\n    const areLabelsDistinct = checkLabelsDistinct(testLabels);\n    if (!areLabelsDistinct) {\n      // console.log('labels are not distinct', _.map(testLabels, 'text'));\n      attempts.push({ labels: testLabels, format, areLabelsDistinct });\n      return false;\n    }\n\n    labels = testLabels;\n    return true;\n  });\n\n  if (!_.isUndefined(goodFormat)) {\n    // found labels which work, return them\n    return {\n      labels,\n      format: goodFormat,\n      areLabelsDistinct: true,\n      collisionCount: 0\n    };\n  } else {\n    // none of the sets of labels are good\n    // if we're not forced to decide, return all the labels we tried (let someone else decide)\n    if (!force) return { attempts };\n\n    // forced to decide, choose the least bad option\n    // super bad, we don't have any label sets with distinct labels. return the last attempt.\n    return _.last(attempts);\n  }\n}\n\nclass YAxisLabels extends React.Component {\n  static propTypes = {\n    /**\n     * D3 scale for Y axis - provided by XYPlot.\n     */\n    yScale: PropTypes.func,\n    height: PropTypes.number,\n    width: PropTypes.number,\n    /**\n     * Position of y axis labels. Accepted options are \"left\" or \"right\".\n     */\n    position: PropTypes.oneOf([\"left\", \"right\"]),\n    /**\n     * Placement of labels in regards to the y axis. Accepted options are \"before\" or \"after\".\n     */\n    placement: PropTypes.oneOf([\"before\", \"after\"]),\n    /**\n     * Label distance from Y Axis.\n     */\n    distance: PropTypes.number,\n    /**\n     * Round ticks to capture extent of given y domain from XYPlot.\n     */\n    nice: PropTypes.bool,\n    /**\n     * Number of ticks on axis.\n     */\n    tickCount: PropTypes.number,\n    /**\n     * Custom ticks to display.\n     */\n    ticks: PropTypes.array,\n    /**\n     * Inline style object applied to each label,\n     * or accessor function which returns a style object\n     *\n     * Disclaimer: labelStyle will merge its defaults with the given labelStyle prop\n     * in order to ensure that our collision library measureText is able to calculate the\n     * smallest amount of possible collisions along the axis. It's therefore dependent on\n     * fontFamily, size and fontStyle to always be passed in. If you're looking to have a centralized\n     * stylesheet, we suggest creating a styled label component that wraps YAxisLabels with your preferred styles.\n     */\n    labelStyle: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n    labelClassName: PropTypes.string,\n    /**\n     * Spacing - provided by XYPlot and used to determine the placement of the label given spacingLeft\n     */\n    spacingLeft: PropTypes.number,\n    /**\n     * Spacing - provided by XYPlot and used to determine the placement of the label given spacingRight\n     */\n    spacingRight: PropTypes.number,\n    /**\n     * `mouseenter` event handler callback, called when user's mouse enters the label.\n     */\n    onMouseEnterLabel: PropTypes.func,\n    /**\n     * `mousemove` event handler callback, called when user's mouse moves within the label.\n     */\n    onMouseMoveLabel: PropTypes.func,\n    /**\n     * `mouseleave` event handler callback, called when user's mouse leaves the label.\n     */\n    onMouseLeaveLabel: PropTypes.func,\n    /**\n     * `mouseclick` event handler callback, called when user's mouse clicks the label.\n     */\n    onMouseClickLabel: PropTypes.func,\n    /**\n     * Format to use for the labels or accessor that returns the updated label.\n     *\n     * For example, given labels with real numbers one can pass in 0.[0] to round to the first significant digit.\n     */\n    format: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    /**\n     * Formats to use for the labels in priority order. XAxisLabels will try to be smart about which format\n     * to use that keeps the labels distinct and provides the least amount of collisions when rendered.\n     *\n     * For example, given labels with real numbers one can pass in 0.[0] to round to the first significant digit\n     */\n    formats: PropTypes.array,\n    /**\n     * Custom labels provided. Note that each object in the array has to be of shape.\n     * `{\n     *  value,\n     *  text,\n     *  height,\n     *  width\n     * }`\n     * value - value you'd like this label to be aligned with\n     * text - text you'd like displayed\n     * height - height of the given label\n     * width - width of the given label\n     */\n    labels: PropTypes.array,\n    /**\n     * Adds vertical offset (along the YAxis) to the labels.\n     */\n    offset: PropTypes.number\n  };\n\n  static defaultProps = {\n    offset: 0,\n    height: 250,\n    width: 400,\n    position: \"left\",\n    distance: 4,\n    nice: true,\n    tickCount: 10,\n    ticks: null,\n    labelClassName: \"\",\n    labelStyle: {\n      fontFamily: \"Helvetica, sans-serif\",\n      fontSize: \"14px\",\n      lineHeight: 1,\n      textAnchor: \"end\"\n    }\n  };\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return !xyPropsEqual(this.props, nextProps);\n  }\n\n  static getTickDomain(props) {\n    if (!props.yScale) return;\n    props = _.defaults({}, props, YAxisLabels.defaultProps);\n    return { yTickDomain: getTickDomain(props.yScale, props) };\n  }\n\n  static getMargin(props) {\n    props = _.defaults({}, props, YAxisLabels.defaultProps);\n    const { yScale, position, placement, distance } = props;\n    const labels = props.labels || YAxisLabels.getLabels(props);\n    const zeroMargin = {\n      marginTop: 0,\n      marginBottom: 0,\n      marginLeft: 0,\n      marginRight: 0\n    };\n\n    if (\n      (position === \"left\" && placement === \"after\") ||\n      (position === \"right\" && placement === \"before\")\n    )\n      return zeroMargin;\n\n    const marginX = _.max(\n      labels.map(label => Math.ceil(distance + label.width))\n    );\n    const [marginTop, marginBottom] = getLabelsYOverhang(\n      yScale,\n      labels,\n      \"middle\"\n    );\n\n    return _.defaults(\n      { [`margin${_.capitalize(position)}`]: marginX, marginTop, marginBottom },\n      zeroMargin\n    );\n  }\n\n  static getDefaultFormats(scaleType) {\n    const timeFormatStrs = [\"YYYY\", \"'YY\", \"MMM YYYY\", \"M/YY\"];\n    const numberFormatStrs = [\n      \"0.[00]a\",\n      \"0,0\",\n      \"0.[0]\",\n      \"0.[00]\",\n      \"0.[0000]\",\n      \"0.[000000]\"\n    ];\n\n    return scaleType === \"ordinal\"\n      ? [_.identity]\n      : scaleType === \"time\"\n        ? timeFormatStrs\n        : numberFormatStrs;\n  }\n\n  static getLabels(props) {\n    const { tickCount, labelStyle, yScale } = _.defaults(\n      props,\n      {},\n      YAxisLabels.defaultProps\n    );\n    const ticks = props.ticks || getScaleTicks(yScale, null, tickCount);\n    const style = {\n      labelStyle,\n      defaultStyle: YAxisLabels.defaultProps.labelStyle\n    };\n    const scaleType = inferScaleType(yScale);\n    const propsFormats = props.format ? [props.format] : props.formats;\n    const formatStrs =\n      _.isArray(propsFormats) && propsFormats.length\n        ? propsFormats\n        : YAxisLabels.getDefaultFormats(scaleType);\n    const formats = makeLabelFormatters(formatStrs, scaleType);\n\n    // todo resolve ticks also\n    // if there are so many ticks that no combination of labels can fit on the axis,\n    // nudge down the tickCount and try again\n    // doing this will require communicating the updated ticks/tickCount back to the parent element...\n\n    const { labels } = resolveYLabelsForValues(yScale, ticks, formats, style);\n    // console.log('resolveYLabelsForValues took ', performance.now() - start);\n    // console.log('found labels', labels);\n    return labels;\n  }\n\n  render() {\n    // todo: position: 'zero' prop to position along the zero line\n    const {\n      width,\n      yScale,\n      position,\n      distance,\n      labelStyle,\n      labelClassName,\n      spacingLeft,\n      spacingRight,\n      offset\n    } = this.props;\n    const placement =\n      this.props.placement || (position === \"left\" ? \"before\" : \"after\");\n    const className = `rct-chart-value-label rct-chart-value-label-y ${labelClassName}`;\n    const textAnchor = placement === \"before\" ? \"end\" : \"start\";\n    const labels = this.props.labels || YAxisLabels.getLabels(this.props);\n    const transform =\n      position === \"left\"\n        ? `translate(${-spacingLeft}, 0)`\n        : `translate(${width + spacingRight}, 0)`;\n\n    return (\n      <g className=\"rct-chart-value-labels-y\" transform={transform}>\n        {labels.map((label, i) => {\n          const y = yScale(label.value) + offset;\n          const x = placement === \"before\" ? -distance : distance;\n\n          const [onMouseEnter, onMouseMove, onMouseLeave, onClick] = [\n            \"onMouseEnterLabel\",\n            \"onMouseMoveLabel\",\n            \"onMouseLeaveLabel\",\n            \"onMouseClickLabel\"\n          ].map(eventName => {\n            // partially apply this bar's data point as 2nd callback argument\n            const callback = _.get(this.props, eventName);\n            return _.isFunction(callback)\n              ? _.partial(callback, _, label.value)\n              : null;\n          });\n\n          const style = _.defaults(\n            { textAnchor },\n            getValue(labelStyle, { x, y, ...label }, i),\n            YAxisLabels.defaultProps.labelStyle\n          );\n\n          return (\n            <g\n              key={`x-axis-label-${i}`}\n              {...{ onMouseEnter, onMouseMove, onMouseLeave, onClick }}\n            >\n              {/* <YAxisLabelDebugRect {...{x, y, label, style: getValue(labelStyle, label.text, i)}}/> */}\n              <MeasuredValueLabel\n                value={label.value}\n                {...{\n                  x,\n                  y,\n                  className,\n                  dy: \"0.35em\",\n                  style\n                }}\n              >\n                {label.text}\n              </MeasuredValueLabel>\n            </g>\n          );\n        })}\n      </g>\n    );\n  }\n}\n\nclass YAxisLabelDebugRect extends React.Component {\n  render() {\n    const { x, y, label, style } = this.props;\n    const xAdj = style.textAnchor === \"end\" ? x - label.width : x;\n    return (\n      <rect\n        {...{\n          x: xAdj,\n          y: y - label.height / 2,\n          width: label.width,\n          height: label.height,\n          fill: \"orange\"\n        }}\n      />\n    );\n  }\n}\n\nexport default YAxisLabels;\n"],"file":"YAxisLabels.js"}