{"version":3,"sources":["../src/KernelDensityEstimation.js"],"names":["CustomPropTypes","KernelDensityEstimation","state","kdeData","nextProps","nextState","shouldUpdate","props","initKDE","newProps","data","bandwidth","sampleCount","xScale","width","kernel","epanechnikovKernel","samples","ticks","Math","ceil","setState","kernelDensityEstimator","d","yDomain","Component","propTypes","array","isRequired","number","name","string","scale","object","axisType","scaleWidth","scaleHeight","defaultProps","x","sample","map","v","u","abs"],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;AACA;;AACA;;;;AAEA;;IAAYA,e;;AACZ;;;;AAEA;;;;;;;;;;;;;;IAEMC,uB;;;;;;;;;;;;;;wNAiCJC,K,GAAQ;AACNC,eAAS;AADH,K;;;;;0CAWcC,S,EAAWC,S,EAAW;AAC1C,UAAMC,eAAe,CAAC,4BAAa,KAAKC,KAAlB,EAAyBH,SAAzB,EAAoC,EAApC,CAAtB;AACA,aAAOE,YAAP;AACD;;;yCAEoB;AACnB,WAAKE,OAAL,CAAa,KAAKD,KAAlB;AACD;;;8CACyBE,Q,EAAU;AAClC,WAAKD,OAAL,CAAaC,QAAb;AACD;;;4BACOF,K,EAAO;AAAA,UACNG,IADM,GACyCH,KADzC,CACNG,IADM;AAAA,UACAC,SADA,GACyCJ,KADzC,CACAI,SADA;AAAA,UACWC,WADX,GACyCL,KADzC,CACWK,WADX;AAAA,UACwBC,MADxB,GACyCN,KADzC,CACwBM,MADxB;AAAA,UACgCC,KADhC,GACyCP,KADzC,CACgCO,KADhC;;AAEb,UAAMC,SAASC,mBAAmBL,SAAnB,CAAf;AACA,UAAMM,UAAUJ,OAAOK,KAAP,CAAaN,eAAeO,KAAKC,IAAL,CAAUN,QAAQ,CAAlB,CAA5B,CAAhB;AACA,WAAKO,QAAL,CAAc,EAAClB,SAASmB,uBAAuBP,MAAvB,EAA+BE,OAA/B,EAAwCP,IAAxC,CAAV,EAAd;AACD;;;6BAEQ;AAAA,UACAP,OADA,GACW,KAAKD,KADhB,CACAC,OADA;;;AAGP,aAAO,gEACD,KAAKI,KADJ;AAEL,cAAMJ,OAFD;AAGL,WAAG;AAAA,iBAAKoB,EAAE,CAAF,CAAL;AAAA,SAHE;AAIL,WAAG;AAAA,iBAAKA,EAAE,CAAF,IAAO,GAAZ;AAAA;AAJE,SAAP;AAMD;;;gCAlCkB;AACjB;AACA,aAAO;AACLC,iBAAS,CAAC,CAAD,EAAG,GAAH;AADJ,OAAP;AAGD;;;;EA1CmC,gBAAMC,S;;AAAtCxB,uB,CACGyB,S,GAAY;AACjB;;;AAGAhB,QAAM,oBAAUiB,KAAV,CAAgBC,UAJL;;AAMjB;;;;AAIAjB,aAAW,oBAAUkB,MAVJ;AAWjB;;;;;AAKAjB,eAAa,oBAAUiB,MAhBN;;AAkBjB;AACA;AACAC,QAAM,oBAAUC,MApBC;AAqBjBC,SAAO,oBAAUC,MArBA;AAsBjBC,YAAU,oBAAUD,MAtBH;AAuBjBE,cAAY,oBAAUN,MAvBL;AAwBjBO,eAAa,oBAAUP;AAxBN,C;AADf5B,uB,CA2BGoC,Y,GAAe;AACpB1B,aAAW,GADS;AAEpBC,eAAa,IAFO,EAED;AACnBkB,QAAM;AAHc,C;;;AA+CxB,SAASR,sBAAT,CAAgCP,MAAhC,EAAwCuB,CAAxC,EAA2C;AACzC,SAAO,UAASC,MAAT,EAAiB;AACtB,WAAOD,EAAEE,GAAF,CAAM,UAASF,CAAT,EAAY;AACvB,aAAO,CAACA,CAAD,EAAI,aAAKC,MAAL,EAAa,UAASE,CAAT,EAAY;AAAE,eAAO1B,OAAOuB,IAAIG,CAAX,CAAP;AAAuB,OAAlD,CAAJ,CAAP;AACD,KAFM,CAAP;AAGD,GAJD;AAKD;;AAED,SAASzB,kBAAT,CAA4BgB,KAA5B,EAAmC;AACjC,SAAO,UAASU,CAAT,EAAY;AACjB,WAAOvB,KAAKwB,GAAL,CAASD,KAAKV,KAAd,KAAwB,CAAxB,GAA4B,OAAO,IAAIU,IAAIA,CAAf,IAAoBV,KAAhD,GAAwD,CAA/D;AACD,GAFD;AAGD;;kBAEc/B,uB","file":"KernelDensityEstimation.js","sourcesContent":["import React from 'react';\nimport _ from 'lodash';\nimport {mean} from 'd3';\nimport PropTypes from 'prop-types';\n\nimport * as CustomPropTypes from './utils/CustomPropTypes';\nimport xyPropsEqual from './utils/xyPropsEqual';\n\nimport LineChart from './LineChart.js';\n\nclass KernelDensityEstimation extends React.Component {\n  static propTypes = {\n    /**\n     * the array of data objects\n     */\n    data: PropTypes.array.isRequired,\n\n    /**\n     * Kernel bandwidth for kernel density estimator.\n     * High bandwidth => oversmoothing & underfitting; low bandwidth => undersmoothing & overfitting\n     */\n    bandwidth: PropTypes.number,\n    /**\n     * Number of samples to take from the KDE,\n     * ie. the resolution/smoothness of the KDE line - more samples => higher resolution, smooth line.\n     * Defaults to null, which causes it to be auto-determined based on width.\n     */\n    sampleCount: PropTypes.number,\n\n    // common props from XYPlot\n    // accessor for data values\n    name: PropTypes.string,\n    scale: PropTypes.object,\n    axisType: PropTypes.object,\n    scaleWidth: PropTypes.number,\n    scaleHeight: PropTypes.number\n  };\n  static defaultProps = {\n    bandwidth: 0.5,\n    sampleCount: null, // null = auto-determined based on width\n    name: ''\n  };\n\n  state = {\n    kdeData: null\n  };\n\n  static getDomain() {\n    // todo implement real static getDomain method\n    return {\n      yDomain: [0,200]\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const shouldUpdate = !xyPropsEqual(this.props, nextProps, []);\n    return shouldUpdate;\n  }\n\n  componentWillMount() {\n    this.initKDE(this.props);\n  }\n  componentWillReceiveProps(newProps) {\n    this.initKDE(newProps);\n  }\n  initKDE(props) {\n    const {data, bandwidth, sampleCount, xScale, width} = props;\n    const kernel = epanechnikovKernel(bandwidth);\n    const samples = xScale.ticks(sampleCount || Math.ceil(width / 2));\n    this.setState({kdeData: kernelDensityEstimator(kernel, samples)(data)});\n  }\n\n  render() {\n    const {kdeData} = this.state;\n\n    return <LineChart\n      {...this.props}\n      data={kdeData}\n      x={d => d[0]}\n      y={d => d[1] * 500}\n    />;\n  }\n}\n\nfunction kernelDensityEstimator(kernel, x) {\n  return function(sample) {\n    return x.map(function(x) {\n      return [x, mean(sample, function(v) { return kernel(x - v); })];\n    });\n  };\n}\n\nfunction epanechnikovKernel(scale) {\n  return function(u) {\n    return Math.abs(u /= scale) <= 1 ? .75 * (1 - u * u) / scale : 0;\n  };\n}\n\nexport default KernelDensityEstimation;\n"]}