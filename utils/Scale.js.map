{"version":3,"sources":["../src/utils/Scale.js"],"names":["scaleTypeFromDataType","dataType","_","get","number","time","categorical","dataTypeFromScaleType","scaleType","linear","log","pow","ordinal","inferDataTypeFromDomain","domain","isArray","Error","length","every","isNumber","isDate","inferScaleType","scale","ticks","base","exponent","initScale","isValidScale","isFunction","range","hasXYScales","isObject","x","y","getScaleTicks","tickCount","getTickDomain","nice","scaleDomain","copy","identity","scaleEqual","scaleA","scaleB","isEqual","indexOfClosestNumberInList","list","reduce","closestI","current","i","Math","abs","invertPointScale","rangeValue","rangePoints","map","domainValue","isDescending","reverse","nearestPointIndex"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { scaleLinear, scaleTime, scalePoint, scaleLog, scalePow } from \"d3\";\n\nimport { combineDomains, domainFromData } from \"./Data\";\n\nexport function scaleTypeFromDataType(dataType) {\n  return _.get(\n    {\n      number: \"linear\",\n      time: \"time\",\n      categorical: \"ordinal\"\n    },\n    dataType,\n    \"ordinal\"\n  );\n}\n\nexport function dataTypeFromScaleType(scaleType) {\n  return _.get(\n    {\n      linear: \"number\",\n      log: \"number\",\n      pow: \"number\",\n      time: \"time\",\n      ordinal: \"categorical\"\n    },\n    scaleType,\n    \"categorical\"\n  );\n}\n\nexport function inferDataTypeFromDomain(domain) {\n  if (!_.isArray(domain))\n    throw new Error(\n      \"invalid domain, inferDataTypeFromDomain cannot infer data type\"\n    );\n\n  return domain.length !== 2\n    ? \"categorical\"\n    : _.every(domain, _.isNumber)\n      ? \"number\"\n      : _.every(domain, _.isDate)\n        ? \"time\"\n        : \"categorical\";\n}\n\nexport function inferScaleType(scale) {\n  return !scale.ticks\n    ? \"ordinal\"\n    : _.isDate(scale.domain()[0])\n      ? \"time\"\n      : scale.base\n        ? \"log\"\n        : scale.exponent\n          ? \"pow\"\n          : \"linear\";\n}\n\nexport function initScale(scaleType) {\n  switch (scaleType) {\n    case \"linear\":\n      return scaleLinear();\n    case \"time\":\n      return scaleTime();\n    case \"ordinal\":\n      return scalePoint();\n    case \"log\":\n      return scaleLog();\n    case \"pow\":\n      return scalePow();\n  }\n}\n\nexport function isValidScale(scale) {\n  return (\n    _.isFunction(scale) &&\n    _.isFunction(scale.domain) &&\n    _.isFunction(scale.range)\n  );\n}\n\nexport function hasXYScales(scale) {\n  return _.isObject(scale) && isValidScale(scale.x) && isValidScale(scale.y);\n}\n\nexport function getScaleTicks(scale, scaleType, tickCount = 10) {\n  scaleType = scaleType || inferScaleType(scale);\n  return scaleType === \"ordinal\" ? scale.domain() : scale.ticks(tickCount);\n}\n\nexport function getTickDomain(scale, { ticks, tickCount, nice } = {}) {\n  const scaleType = inferScaleType(scale);\n  const scaleDomain = scale.domain();\n\n  if (nice && scaleType !== \"ordinal\") {\n    // If nicing, initialize a new scale and nice it\n    scale = scale\n      .copy()\n      .domain(scaleDomain)\n      .nice(tickCount || 10);\n  }\n\n  if (_.isArray(ticks)) {\n    return combineDomains([\n      scale.domain(),\n      domainFromData(ticks, _.identity, dataTypeFromScaleType(scaleType))\n    ]);\n  } else if (nice && scaleType !== \"ordinal\") return scale.domain();\n  // return undefined by default, if we have no options pertaining to ticks\n}\n\nexport function scaleEqual(scaleA, scaleB) {\n  return !isValidScale(scaleA) || !isValidScale(scaleB)\n    ? scaleA === scaleB // safe fallback\n    : // check scale equality\n      _.isEqual(scaleA.domain(), scaleB.domain()) &&\n        _.isEqual(scaleA.range(), scaleB.range());\n}\n\nexport function indexOfClosestNumberInList(number, list) {\n  return list.reduce((closestI, current, i) => {\n    return Math.abs(current - number) < Math.abs(list[closestI] - number)\n      ? i\n      : closestI;\n  }, 0);\n}\n\nexport function invertPointScale(scale, rangeValue) {\n  const domain = scale.domain();\n\n  // shim until d3.scalePoint.invert() is implemented for real\n  // given a value from the output range, returns the *nearest* corresponding value in the input domain\n  const rangePoints = domain.map(domainValue => scale(domainValue));\n\n  if (rangePoints.length <= 1) {\n    return domain[0];\n  }\n\n  const isDescending = rangePoints[0] > rangePoints[1];\n\n  // _.sortedIndex works on ascending lists only\n  // so reverse if working with descending list\n  if (isDescending) {\n    domain.reverse();\n    rangePoints.reverse();\n  }\n\n  const nearestPointIndex = indexOfClosestNumberInList(rangeValue, rangePoints);\n\n  return domain[nearestPointIndex];\n}\n"],"file":"Scale.js"}