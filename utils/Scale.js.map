{"version":3,"sources":["../src/utils/Scale.js"],"names":["scaleTypeFromDataType","dataTypeFromScaleType","inferDataTypeFromDomain","inferScaleType","initScale","isValidScale","hasXYScales","getScaleTicks","getTickDomain","scaleEqual","dataType","get","number","time","categorical","scaleType","linear","log","pow","ordinal","domain","isArray","Error","length","every","isNumber","isDate","scale","ticks","base","exponent","isFunction","range","isObject","x","y","tickCount","nice","identity","scaleA","scaleB","isEqual"],"mappings":"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","file":"Scale.js","sourcesContent":["import _ from \"lodash\";\nimport React from \"react\";\nimport { scaleLinear, scaleTime, scalePoint, scaleLog, scalePow } from \"d3\";\n\nimport { combineDomains, domainFromData } from \"./Data\";\n\nexport function scaleTypeFromDataType(dataType) {\n  return _.get(\n    {\n      number: \"linear\",\n      time: \"time\",\n      categorical: \"ordinal\"\n    },\n    dataType,\n    \"ordinal\"\n  );\n}\n\nexport function dataTypeFromScaleType(scaleType) {\n  return _.get(\n    {\n      linear: \"number\",\n      log: \"number\",\n      pow: \"number\",\n      time: \"time\",\n      ordinal: \"categorical\"\n    },\n    scaleType,\n    \"categorical\"\n  );\n}\n\nexport function inferDataTypeFromDomain(domain) {\n  if (!_.isArray(domain))\n    throw new Error(\n      \"invalid domain, inferDataTypeFromDomain cannot infer data type\"\n    );\n\n  return domain.length !== 2\n    ? \"categorical\"\n    : _.every(domain, _.isNumber)\n      ? \"number\"\n      : _.every(domain, _.isDate)\n        ? \"time\"\n        : \"categorical\";\n}\n\nexport function inferScaleType(scale) {\n  return !scale.ticks\n    ? \"ordinal\"\n    : _.isDate(scale.domain()[0])\n      ? \"time\"\n      : scale.base\n        ? \"log\"\n        : scale.exponent\n          ? \"pow\"\n          : \"linear\";\n}\n\nexport function initScale(scaleType) {\n  switch (scaleType) {\n    case \"linear\":\n      return scaleLinear();\n    case \"time\":\n      return scaleTime();\n    case \"ordinal\":\n      return scalePoint();\n    case \"log\":\n      return scaleLog();\n    case \"pow\":\n      return scalePow();\n  }\n}\n\nexport function isValidScale(scale) {\n  return (\n    _.isFunction(scale) &&\n    _.isFunction(scale.domain) &&\n    _.isFunction(scale.range)\n  );\n}\n\nexport function hasXYScales(scale) {\n  return _.isObject(scale) && isValidScale(scale.x) && isValidScale(scale.y);\n}\n\nexport function getScaleTicks(scale, scaleType, tickCount = 10) {\n  scaleType = scaleType || inferScaleType(scale);\n  return scaleType === \"ordinal\" ? scale.domain() : scale.ticks(tickCount);\n}\n\nexport function getTickDomain(scale, { ticks, tickCount, nice } = {}) {\n  const scaleType = inferScaleType(scale);\n  // bug - d3 linearScale.copy().nice() modifies original scale, so we must create a new scale instead of copy()ing\n  // todo replace this with d3-scale from d3 v4.0\n  if (nice && scaleType !== \"ordinal\") {\n    scale = initScale(scaleType)\n      .domain(scale.domain())\n      .nice(tickCount || 10);\n  }\n\n  if (_.isArray(ticks)) {\n    return combineDomains([\n      scale.domain(),\n      domainFromData(ticks, _.identity, dataTypeFromScaleType(scaleType))\n    ]);\n  } else if (nice && scaleType !== \"ordinal\") return scale.domain();\n  // return undefined by default, if we have no options pertaining to ticks\n}\n\nexport function scaleEqual(scaleA, scaleB) {\n  return !isValidScale(scaleA) || !isValidScale(scaleB)\n    ? scaleA === scaleB // safe fallback\n    : // check scale equality\n      _.isEqual(scaleA.domain(), scaleB.domain()) &&\n        _.isEqual(scaleA.range(), scaleB.range()) &&\n        _.isEqual(getScaleTicks(scaleA), getScaleTicks(scaleB)); // todo is this necessary?\n}\n"]}