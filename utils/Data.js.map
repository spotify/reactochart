{"version":3,"sources":["../src/utils/Data.js"],"names":["makeAccessor","key","_","isFunction","isNull","isUndefined","identity","property","makeAccessor2","valueOrAccessor","getValue","accessor","args","datasetsFromPropsOrDescendants","props","isArray","datasets","data","React","Children","count","children","forEach","child","concat","inferDataType","Error","every","d","i","isNumber","isDate","inferDatasetsType","types","map","uniqTypes","uniq","length","isValidDomain","domain","type","combineDomains","domains","dataType","undefined","flatten","compact","combineBorderObjects","borderObjects","fromPairs","k","get","maxBy","domainFromData","getDataDomainByAxis","horizontal","getX","getY","rangeAxis","domainFromDatasets","domainFromRangeData","rangeStartAccessor","rangeEndAccessor","combineDatasets","datasetsInfo","combineKey","datasetLookups","datasetInfo","keyBy","allCombineValues","uniqBy","toString","sortBy","value","combineValue","combinedDatum","datasetIndex","dataKeys","Object","keys","datasetLookup","has","datum","newDataKey","originalDataKey"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { extent } from \"d3\";\nimport React from \"react\";\n\n/**\n * `makeAccessor` creates an accessor or \"getter\" function given a variety of options\n * to be used for retrieving a data value from within an object or array\n *\n * If given a function, it is passed through.\n * If given null or undefined, the getter is the identity function - ie. returns whatever it's passed\n * If given an array index or deep object key string, the value will be retrieved using _.property\n *\n * @example\n * makeAccessor(null)(4); // 4\n * makeAccessor(d => d + 1)(4); // 5\n * makeAccessor(1)(['a', 'b', 'c']); // 'b'\n * makeAccessor('x.0.y')({x: [{y: 9}]}); // 9\n *\n * @param {any} key - Getter, which may be a function, integer, string, null, or undefined;\n * @returns {function} accessor - Accessor function\n */\nexport function makeAccessor(key) {\n  return _.isFunction(key)\n    ? key\n    : _.isNull(key) || _.isUndefined(key)\n      ? _.identity\n      : _.property(key);\n}\n\n/**\n * `makeAccessor2` creates a constant accessor function if passed a value,\n * if passed a function, just returns it\n */\nexport function makeAccessor2(valueOrAccessor) {\n  if (_.isFunction(valueOrAccessor)) return valueOrAccessor;\n  return () => valueOrAccessor;\n}\n\n/**\n * `getValue` takes as its first argument a value or an accessor function.\n * If it's a value (ie not a function), it is returned.\n * If a function, returns the result of calling function with remaining arguments\n */\nexport function getValue(accessor, ...args) {\n  return _.isFunction(accessor) ? accessor(...args) : accessor;\n}\n\n/**\n * `datasetsFromPropsOrDescendants` expects a `props` object which may have `children`.\n * if `props` has `data` or `datasets`, returns it; otherwise recursively searches props.children\n * for components have `data` or `datasets` and combines them into one `datasets` array.\n * `props.data` is wrapped in array because this returns `datasets` (multiple arrays of `data`)\n *\n * @param {Object} props - A React props object, which may have `children` with their own props.\n * @returns {Array.<Array>} datasets - An array of arrays of data objects\n */\nexport function datasetsFromPropsOrDescendants(props) {\n  if (_.isArray(props.datasets)) {\n    return props.datasets;\n  } else if (_.isArray(props.data)) {\n    return [props.data];\n  } else if (React.Children.count(props.children)) {\n    let datasets = [];\n    // use Children.forEach instead of map, because Children.map flattens the arrays\n    React.Children.forEach(props.children, child => {\n      datasets = datasets.concat(datasetsFromPropsOrDescendants(child.props));\n    });\n    return datasets;\n  }\n  return [];\n}\n\nexport function inferDataType(data, accessor = _.identity) {\n  if (!_.isArray(data)) throw new Error(\"inferDataType expects a data array\");\n  else if (_.every(data, (d, i) => _.isUndefined(accessor(d, i))))\n    return \"categorical\";\n  // should this be allowed?\n  else if (\n    _.every(\n      data,\n      (d, i) => _.isNumber(accessor(d, i)) || _.isUndefined(accessor(d, i))\n    )\n  )\n    return \"number\";\n  else if (\n    _.every(\n      data,\n      (d, i) => _.isDate(accessor(d, i)) || _.isUndefined(accessor(d, i))\n    )\n  )\n    return \"time\";\n  else return \"categorical\";\n}\n\nexport function inferDatasetsType(datasets, accessor = _.identity) {\n  if (!_.isArray(datasets))\n    throw new Error(\"inferDatasetsType expects a datasets array\");\n\n  const types = datasets.map(data => inferDataType(data, accessor));\n  const uniqTypes = _.uniq(types);\n  return uniqTypes.length === 1 ? uniqTypes[0] : \"categorical\";\n}\n\nexport function isValidDomain(domain, type = \"categorical\") {\n  return (\n    _.isArray(domain) &&\n    !!domain.length &&\n    // categorical domain can be any array of anything\n    (type === \"categorical\" ||\n      // number/time domains should look like [min, max]\n      (type === \"number\" &&\n        domain.length === 2 &&\n        _.every(domain, _.isNumber)) ||\n      (type === \"time\" && domain.length === 2 && _.every(domain, _.isDate)))\n  );\n}\n\nexport function combineDomains(domains, dataType) {\n  if (!_.isArray(domains)) return undefined;\n  return dataType === \"categorical\"\n    ? _.uniq(_.flatten(_.compact(domains)))\n    : extent(_.flatten(domains));\n}\n\nexport function combineBorderObjects(borderObjects) {\n  return _.fromPairs(\n    [\"top\", \"bottom\", \"left\", \"right\"].map(k => {\n      // combine border objects by taking the max value of each spacing direction\n      return [k, _.get(_.maxBy(borderObjects, k), k)];\n    })\n  );\n}\n\nexport function domainFromData(data, accessor = _.identity, type = undefined) {\n  if (!type) type = inferDataType(data, accessor);\n  return type === \"number\" || type === \"time\"\n    ? extent(data.map(accessor))\n    : _.uniq(data.map(accessor));\n}\n\nexport function getDataDomainByAxis(props) {\n  const { horizontal, data, getX, getY } = props;\n  const accessor = horizontal ? makeAccessor(getY) : makeAccessor(getX);\n  const rangeAxis = horizontal ? \"y\" : \"x\";\n  return {\n    [rangeAxis]: domainFromData(data, accessor)\n  };\n}\n\nexport function domainFromDatasets(\n  datasets,\n  accessor = _.identity,\n  type = undefined\n) {\n  // returns the default domain of a collection of datasets with an accessor function\n  // for numeric and date-type datasets, returns the extent (min and max) of the numbers/dates\n  // for categorical datasets, returns the set of distinct category values\n  if (!type) type = inferDatasetsType(datasets, accessor);\n  const domains = datasets.map(data => domainFromData(data, accessor, type));\n  return combineDomains(domains, type);\n}\n\nexport function domainFromRangeData(\n  data,\n  rangeStartAccessor,\n  rangeEndAccessor,\n  dataType\n) {\n  // returns the domain of dataset for which each datum represents a range of values\n  // ie. has a start and end value rather than a single value\n  // for example, time ranges\n\n  if (!dataType) dataType = inferDataType(data, rangeStartAccessor);\n  switch (dataType) {\n    case \"number\":\n    case \"time\":\n      return extent(\n        _.flatten([\n          extent(data, (d, i) => +rangeStartAccessor(d, i)),\n          extent(data, (d, i) => +rangeEndAccessor(d, i))\n        ])\n      );\n    case \"categorical\":\n      return _.uniq(\n        _.flatten([data.map(rangeStartAccessor), data.map(rangeEndAccessor)])\n      );\n  }\n  return [];\n}\n\nexport function combineDatasets(datasetsInfo = [], combineKey = \"x\") {\n  // combineDatasets combines multiple datasets into one, joined on a common key 'combineKey'\n  // datasetsInfo is an array that looks like:\n  // [\n  //   {data: [{x: 0, y: 3}, ...], combineKey: 'x', dataKeys: {y: 'y0'}}\n  //   {data: [{count: 0, value: 4}], combineKey: 'count', dataKeys: {value: 'y1'}}\n  // ]\n  // where `data` is an array of data points of any shape\n  // `combineKey` is the key for the value which the datasets are joined on\n  // `dataKeys` are getters for other values in each datapoint which should be merged into the combined dataset\n  //   - key = getter in original datapoint, value = setter for combined dataset\n  // example above (with default combinedKey) results in:\n  // [{x: 0, y0: 3, y1: 4}, ...]\n\n  // index each dataset by its combineKey values so we can quickly lookup if it has data for a given value\n  const datasetLookups = datasetsInfo.map(datasetInfo => {\n    const { data } = datasetInfo;\n    return _.keyBy(data, datasetInfo.combineKey || combineKey);\n  });\n\n  // create a unique sorted array containing all of the data values for combineKey in all datasets\n  const allCombineValues = _(datasetsInfo)\n    .map(datasetInfo =>\n      datasetInfo.data.map(makeAccessor(datasetInfo.combineKey || combineKey))\n    )\n    .flatten()\n    .uniqBy(_.toString) // uniq by string, otherwise dates etc. are not unique\n    .sortBy()\n    .value();\n\n  // for each of the unique combineKey data values, go through each dataset and look for a combineKey value that matches\n  // if we find it, combine the values for that datum's dataKeys into the final combinedDatum object\n  return allCombineValues.map(combineValue => {\n    let combinedDatum = { [combineKey]: combineValue };\n\n    datasetsInfo.forEach((datasetInfo, datasetIndex) => {\n      if (!datasetInfo.dataKeys || !Object.keys(datasetInfo.dataKeys).length)\n        return;\n      const datasetLookup = datasetLookups[datasetIndex];\n      if (!_.has(datasetLookup, combineValue)) return;\n\n      const datum = datasetLookup[combineValue];\n      _.forEach(datasetInfo.dataKeys, (newDataKey, originalDataKey) => {\n        combinedDatum[newDataKey] = datum[originalDataKey];\n      });\n    });\n\n    return combinedDatum;\n  });\n}\n"],"file":"Data.js"}