{"version":3,"sources":["../src/utils/Data.js"],"names":["makeAccessor","makeAccessor2","getValue","datasetsFromPropsOrDescendants","inferDataType","inferDatasetsType","isValidDomain","combineDomains","combineBorderObjects","domainFromData","getDataDomainByAxis","domainFromDatasets","domainFromRangeData","combineDatasets","key","isFunction","isNull","isUndefined","identity","property","valueOrAccessor","accessor","args","props","isArray","datasets","data","Children","count","children","forEach","concat","child","Error","every","d","i","isNumber","isDate","types","map","uniqTypes","uniq","length","domain","type","domains","dataType","undefined","flatten","compact","borderObjects","fromPairs","k","get","maxBy","horizontal","getX","getY","rangeAxis","rangeStartAccessor","rangeEndAccessor","datasetsInfo","combineKey","datasetLookups","datasetInfo","keyBy","allCombineValues","uniqBy","toString","sortBy","value","combinedDatum","combineValue","datasetIndex","dataKeys","Object","keys","datasetLookup","has","datum","newDataKey","originalDataKey"],"mappings":"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","file":"Data.js","sourcesContent":["import _ from \"lodash\";\nimport { extent } from \"d3\";\nimport React from \"react\";\n\n/**\n * `makeAccessor` creates an accessor or \"getter\" function given a variety of options\n * to be used for retrieving a data value from within an object or array\n *\n * If given a function, it is passed through.\n * If given null or undefined, the getter is the identity function - ie. returns whatever it's passed\n * If given an array index or deep object key string, the value will be retrieved using _.property\n *\n * @example\n * makeAccessor(null)(4); // 4\n * makeAccessor(d => d + 1)(4); // 5\n * makeAccessor(1)(['a', 'b', 'c']); // 'b'\n * makeAccessor('x.0.y')({x: [{y: 9}]}); // 9\n *\n * @param {any} key - Getter, which may be a function, integer, string, null, or undefined;\n * @returns {function} accessor - Accessor function\n */\nexport function makeAccessor(key) {\n  return _.isFunction(key)\n    ? key\n    : _.isNull(key) || _.isUndefined(key)\n      ? _.identity\n      : _.property(key);\n}\n\n/**\n * `makeAccessor2` creates a constant accessor function if passed a value,\n * if passed a function, just returns it\n */\nexport function makeAccessor2(valueOrAccessor) {\n  if (_.isFunction(valueOrAccessor)) return valueOrAccessor;\n  return () => valueOrAccessor;\n}\n\n/**\n * `getValue` takes as its first argument a value or an accessor function.\n * If it's a value (ie not a function), it is returned.\n * If a function, returns the result of calling function with remaining arguments\n */\nexport function getValue(accessor, ...args) {\n  return _.isFunction(accessor) ? accessor(...args) : accessor;\n}\n\n/**\n * `datasetsFromPropsOrDescendants` expects a `props` object which may have `children`.\n * if `props` has `data` or `datasets`, returns it; otherwise recursively searches props.children\n * for components have `data` or `datasets` and combines them into one `datasets` array.\n * `props.data` is wrapped in array because this returns `datasets` (multiple arrays of `data`)\n *\n * @param {Object} props - A React props object, which may have `children` with their own props.\n * @returns {Array.<Array>} datasets - An array of arrays of data objects\n */\nexport function datasetsFromPropsOrDescendants(props) {\n  if (_.isArray(props.datasets)) {\n    return props.datasets;\n  } else if (_.isArray(props.data)) {\n    return [props.data];\n  } else if (React.Children.count(props.children)) {\n    let datasets = [];\n    // use Children.forEach instead of map, because Children.map flattens the arrays\n    React.Children.forEach(props.children, child => {\n      datasets = datasets.concat(datasetsFromPropsOrDescendants(child.props));\n    });\n    return datasets;\n  }\n  return [];\n}\n\nexport function inferDataType(data, accessor = _.identity) {\n  if (!_.isArray(data)) throw new Error(\"inferDataType expects a data array\");\n  else if (_.every(data, (d, i) => _.isUndefined(accessor(d, i))))\n    return \"categorical\";\n  // should this be allowed?\n  else if (\n    _.every(\n      data,\n      (d, i) => _.isNumber(accessor(d, i)) || _.isUndefined(accessor(d, i))\n    )\n  )\n    return \"number\";\n  else if (\n    _.every(\n      data,\n      (d, i) => _.isDate(accessor(d, i)) || _.isUndefined(accessor(d, i))\n    )\n  )\n    return \"time\";\n  else return \"categorical\";\n}\n\nexport function inferDatasetsType(datasets, accessor = _.identity) {\n  if (!_.isArray(datasets))\n    throw new Error(\"inferDatasetsType expects a datasets array\");\n\n  const types = datasets.map(data => inferDataType(data, accessor));\n  const uniqTypes = _.uniq(types);\n  return uniqTypes.length === 1 ? uniqTypes[0] : \"categorical\";\n}\n\nexport function isValidDomain(domain, type = \"categorical\") {\n  return (\n    _.isArray(domain) &&\n    !!domain.length &&\n    // categorical domain can be any array of anything\n    (type === \"categorical\" ||\n      // number/time domains should look like [min, max]\n      (type === \"number\" &&\n        domain.length === 2 &&\n        _.every(domain, _.isNumber)) ||\n      (type === \"time\" && domain.length === 2 && _.every(domain, _.isDate)))\n  );\n}\n\nexport function combineDomains(domains, dataType) {\n  if (!_.isArray(domains)) return undefined;\n  return dataType === \"categorical\"\n    ? _.uniq(_.flatten(_.compact(domains)))\n    : extent(_.flatten(domains));\n}\n\nexport function combineBorderObjects(borderObjects) {\n  return _.fromPairs(\n    [\"top\", \"bottom\", \"left\", \"right\"].map(k => {\n      // combine border objects by taking the max value of each spacing direction\n      return [k, _.get(_.maxBy(borderObjects, k), k)];\n    })\n  );\n}\n\nexport function domainFromData(data, accessor = _.identity, type = undefined) {\n  if (!type) type = inferDataType(data, accessor);\n  return type === \"number\" || type === \"time\"\n    ? extent(data.map(accessor))\n    : _.uniq(data.map(accessor));\n}\n\nexport function getDataDomainByAxis(props) {\n  const { horizontal, data, getX, getY } = props;\n  const accessor = horizontal ? makeAccessor(getY) : makeAccessor(getX);\n  const rangeAxis = horizontal ? \"y\" : \"x\";\n  return {\n    [rangeAxis]: domainFromData(data, accessor)\n  };\n}\n\nexport function domainFromDatasets(\n  datasets,\n  accessor = _.identity,\n  type = undefined\n) {\n  // returns the default domain of a collection of datasets with an accessor function\n  // for numeric and date-type datasets, returns the extent (min and max) of the numbers/dates\n  // for categorical datasets, returns the set of distinct category values\n  if (!type) type = inferDatasetsType(datasets, accessor);\n  const domains = datasets.map(data => domainFromData(data, accessor, type));\n  return combineDomains(domains, type);\n}\n\nexport function domainFromRangeData(\n  data,\n  rangeStartAccessor,\n  rangeEndAccessor,\n  dataType\n) {\n  // returns the domain of dataset for which each datum represents a range of values\n  // ie. has a start and end value rather than a single value\n  // for example, time ranges\n\n  if (!dataType) dataType = inferDataType(data, rangeStartAccessor);\n  switch (dataType) {\n    case \"number\":\n    case \"time\":\n      return extent(\n        _.flatten([\n          extent(data, (d, i) => +rangeStartAccessor(d, i)),\n          extent(data, (d, i) => +rangeEndAccessor(d, i))\n        ])\n      );\n    case \"categorical\":\n      return _.uniq(\n        _.flatten([data.map(rangeStartAccessor), data.map(rangeEndAccessor)])\n      );\n  }\n  return [];\n}\n\nexport function combineDatasets(datasetsInfo = [], combineKey = \"x\") {\n  // combineDatasets combines multiple datasets into one, joined on a common key 'combineKey'\n  // datasetsInfo is an array that looks like:\n  // [\n  //   {data: [{x: 0, y: 3}, ...], combineKey: 'x', dataKeys: {y: 'y0'}}\n  //   {data: [{count: 0, value: 4}], combineKey: 'count', dataKeys: {value: 'y1'}}\n  // ]\n  // where `data` is an array of data points of any shape\n  // `combineKey` is the key for the value which the datasets are joined on\n  // `dataKeys` are getters for other values in each datapoint which should be merged into the combined dataset\n  //   - key = getter in original datapoint, value = setter for combined dataset\n  // example above (with default combinedKey) results in:\n  // [{x: 0, y0: 3, y1: 4}, ...]\n\n  // index each dataset by its combineKey values so we can quickly lookup if it has data for a given value\n  const datasetLookups = datasetsInfo.map(datasetInfo => {\n    const { data } = datasetInfo;\n    return _.keyBy(data, datasetInfo.combineKey || combineKey);\n  });\n\n  // create a unique sorted array containing all of the data values for combineKey in all datasets\n  const allCombineValues = _(datasetsInfo)\n    .map(datasetInfo =>\n      datasetInfo.data.map(makeAccessor(datasetInfo.combineKey || combineKey))\n    )\n    .flatten()\n    .uniqBy(_.toString) // uniq by string, otherwise dates etc. are not unique\n    .sortBy()\n    .value();\n\n  // for each of the unique combineKey data values, go through each dataset and look for a combineKey value that matches\n  // if we find it, combine the values for that datum's dataKeys into the final combinedDatum object\n  return allCombineValues.map(combineValue => {\n    let combinedDatum = { [combineKey]: combineValue };\n\n    datasetsInfo.forEach((datasetInfo, datasetIndex) => {\n      if (!datasetInfo.dataKeys || !Object.keys(datasetInfo.dataKeys).length)\n        return;\n      const datasetLookup = datasetLookups[datasetIndex];\n      if (!_.has(datasetLookup, combineValue)) return;\n\n      const datum = datasetLookup[combineValue];\n      _.forEach(datasetInfo.dataKeys, (newDataKey, originalDataKey) => {\n        combinedDatum[newDataKey] = datum[originalDataKey];\n      });\n    });\n\n    return combinedDatum;\n  });\n}\n"]}