{"version":3,"sources":["src/ColorHeatmap.js"],"names":["interpolatorFromType","type","toLowerCase","interpolateHcl","interpolateHsl","interpolateLab","interpolateRgb","makeColorScale","domain","colors","interpolator","_","isString","range","interpolate","ColorHeatmap","React","Component","getDomain","props","xScaleType","yScaleType","data","x","xEnd","y","yEnd","shouldComponentUpdate","nextProps","shouldUpdate","render","xScale","yScale","value","rectStyle","rectClassName","valueAccessor","colorScale","valueDomain","length","times","scale","schemeCategory10","map","d","i","color","style","fill","className","key","PropTypes","array","isRequired","CustomPropTypes","valueOrAccessor","func","string","oneOfType","object"],"mappings":"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","sourcesContent":["import {\n  interpolateHcl,\n  interpolateHsl,\n  interpolateLab,\n  interpolateRgb,\n  scaleLinear\n} from \"d3\";\nimport _ from \"lodash\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport RangeRect from \"./RangeRect\";\nimport * as CustomPropTypes from \"./utils/CustomPropTypes\";\nimport {\n  domainFromData,\n  domainFromRangeData,\n  getValue,\n  makeAccessor2\n} from \"./utils/Data\";\nimport { dataTypeFromScaleType } from \"./utils/Scale\";\nimport xyPropsEqual from \"./utils/xyPropsEqual\";\n\nfunction interpolatorFromType(type) {\n  switch (type.toLowerCase()) {\n    case \"hcl\":\n      return interpolateHcl;\n    case \"hsl\":\n      return interpolateHsl;\n    case \"lab\":\n      return interpolateLab;\n    case \"rgb\":\n      return interpolateRgb;\n    default:\n      return interpolateLab;\n  }\n}\n\nfunction makeColorScale(domain, colors, interpolator) {\n  // invariant(domain.length === colors.length, 'ColorHeatmap makeColorScale: domain.length should equal colors.length');\n\n  if (_.isString(interpolator))\n    interpolator = interpolatorFromType(interpolator);\n\n  return scaleLinear()\n    .domain(domain)\n    .range(colors)\n    .interpolate(interpolator);\n}\n\n/**\n * `ColorHeatmap` can be used to represent individual values contained in a matrix through colors.\n */\nexport default class ColorHeatmap extends React.Component {\n  static propTypes = {\n    /**\n     * Array of data to be plotted - should be 1D array of all grid values\n     */\n    data: PropTypes.array.isRequired,\n    value: CustomPropTypes.valueOrAccessor,\n    /**\n     * Accessor function for x values, called once per datum.\n     */\n    x: CustomPropTypes.valueOrAccessor,\n    /**\n     * Accessor function for x end values, called once per datum.\n     */\n    xEnd: CustomPropTypes.valueOrAccessor,\n    /**\n     * Accessor function for y values, called once per datum.\n     */\n    y: CustomPropTypes.valueOrAccessor,\n    /**\n     * Accessor function for y end values, called once per datum.\n     */\n    yEnd: CustomPropTypes.valueOrAccessor,\n    /**\n     * D3 scale for X axis - provided by XYPlot\n     */\n    xScale: PropTypes.func,\n    /**\n     * D3 scale for Y axis - provided by XYPlot\n     */\n    yScale: PropTypes.func,\n    /**\n     * a custom d3 color scale may be passed...\n     */\n    colorScale: PropTypes.func,\n    /**\n     * ...or else one will be constructed from colors, valueDomain and interpolator\n     */\n    colors: PropTypes.array,\n    /**\n     * Custom domain of the passed in data.\n     * Otherwise it will be the extent of your data.\n     */\n    valueDomain: PropTypes.array,\n    /**\n     * Interpolator for colors. Possible options include \"hcl\", \"hsl\", \"lab\" and \"rgb\"\n     */\n    interpolator: PropTypes.string,\n    /**\n     * Inline style object to be applied to each rect,\n     * or accessor function which returns a style object.\n     */\n    rectStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n    /**\n     * Class attribute to be applied to each rect,\n     * or accessor function which returns a class.\n     */\n    rectClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.func])\n  };\n  static defaultProps = {\n    interpolator: \"lab\",\n    rectStyle: {},\n    rectClassName: \"\"\n  };\n\n  static getDomain(props) {\n    const { xScaleType, yScaleType, data, x, xEnd, y, yEnd } = props;\n    return {\n      x: domainFromRangeData(\n        data,\n        makeAccessor2(x),\n        makeAccessor2(xEnd),\n        dataTypeFromScaleType(xScaleType)\n      ),\n      y: domainFromRangeData(\n        data,\n        makeAccessor2(y),\n        makeAccessor2(yEnd),\n        dataTypeFromScaleType(yScaleType)\n      )\n    };\n  }\n\n  shouldComponentUpdate(nextProps) {\n    const shouldUpdate = !xyPropsEqual(this.props, nextProps, [\n      \"colors\",\n      \"valueDomain\"\n    ]);\n    return shouldUpdate;\n  }\n\n  render() {\n    const {\n      data,\n      xScale,\n      yScale,\n      value,\n      x,\n      xEnd,\n      y,\n      yEnd,\n      interpolator,\n      rectStyle,\n      rectClassName\n    } = this.props;\n    const valueAccessor = makeAccessor2(value);\n    let colorScale;\n\n    if (this.props.colorScale) {\n      colorScale = this.props.colorScale;\n    } else {\n      const valueDomain =\n        this.props.valueDomain || domainFromData(data, valueAccessor);\n      const colors =\n        this.props.colors ||\n        (valueDomain.length === 2\n          ? [\"#000000\", \"#ffffff\"]\n          : _.times(\n              valueDomain.length,\n              scale.schemeCategory10().domain(_.range(10))\n            ));\n      colorScale = makeColorScale(valueDomain, colors, interpolator);\n    }\n\n    return (\n      <g className=\"rct-color-heatmap-chart\">\n        {data.map((d, i) => {\n          const color = colorScale(valueAccessor(d));\n          const style = { ...getValue(rectStyle, d, i), fill: color };\n          const className = `${getValue(rectClassName, d, i)}`;\n          const key = `heatmap-rect-${i}`;\n          return (\n            <RangeRect\n              x={getValue(x, d, i)}\n              xEnd={getValue(xEnd, d, i)}\n              y={getValue(y, d, i)}\n              yEnd={getValue(yEnd, d, i)}\n              {...{ xScale, yScale, style, className, key }}\n            />\n          );\n        })}\n      </g>\n    );\n  }\n}\n"],"file":"ColorHeatmap.js"}